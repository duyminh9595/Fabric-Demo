/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.Timestamp = (function() {
    
                /**
                 * Properties of a Timestamp.
                 * @memberof google.protobuf
                 * @interface ITimestamp
                 * @property {number|Long|null} [seconds] Timestamp seconds
                 * @property {number|null} [nanos] Timestamp nanos
                 */
    
                /**
                 * Constructs a new Timestamp.
                 * @memberof google.protobuf
                 * @classdesc Represents a Timestamp.
                 * @implements ITimestamp
                 * @constructor
                 * @param {google.protobuf.ITimestamp=} [properties] Properties to set
                 */
                function Timestamp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Timestamp seconds.
                 * @member {number|Long} seconds
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 */
                Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Timestamp nanos.
                 * @member {number} nanos
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 */
                Timestamp.prototype.nanos = 0;
    
                /**
                 * Creates a new Timestamp instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp=} [properties] Properties to set
                 * @returns {google.protobuf.Timestamp} Timestamp instance
                 */
                Timestamp.create = function create(properties) {
                    return new Timestamp(properties);
                };
    
                /**
                 * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                    if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                    return writer;
                };
    
                /**
                 * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Timestamp message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Timestamp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Timestamp message.
                 * @function verify
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Timestamp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                            return "seconds: integer|Long expected";
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        if (!$util.isInteger(message.nanos))
                            return "nanos: integer expected";
                    return null;
                };
    
                /**
                 * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.Timestamp} Timestamp
                 */
                Timestamp.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.Timestamp)
                        return object;
                    var message = new $root.google.protobuf.Timestamp();
                    if (object.seconds != null)
                        if ($util.Long)
                            (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                        else if (typeof object.seconds === "string")
                            message.seconds = parseInt(object.seconds, 10);
                        else if (typeof object.seconds === "number")
                            message.seconds = object.seconds;
                        else if (typeof object.seconds === "object")
                            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                    if (object.nanos != null)
                        message.nanos = object.nanos | 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.Timestamp} message Timestamp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Timestamp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seconds = options.longs === String ? "0" : 0;
                        object.nanos = 0;
                    }
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (typeof message.seconds === "number")
                            object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                        else
                            object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        object.nanos = message.nanos;
                    return object;
                };
    
                /**
                 * Converts this Timestamp to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Timestamp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Timestamp;
            })();
    
            protobuf.Empty = (function() {
    
                /**
                 * Properties of an Empty.
                 * @memberof google.protobuf
                 * @interface IEmpty
                 */
    
                /**
                 * Constructs a new Empty.
                 * @memberof google.protobuf
                 * @classdesc Represents an Empty.
                 * @implements IEmpty
                 * @constructor
                 * @param {google.protobuf.IEmpty=} [properties] Properties to set
                 */
                function Empty(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new Empty instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {google.protobuf.IEmpty=} [properties] Properties to set
                 * @returns {google.protobuf.Empty} Empty instance
                 */
                Empty.create = function create(properties) {
                    return new Empty(properties);
                };
    
                /**
                 * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Empty.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Empty.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Empty message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Empty} Empty
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Empty.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Empty message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.Empty} Empty
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Empty.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Empty message.
                 * @function verify
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Empty.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an Empty message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.Empty} Empty
                 */
                Empty.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.Empty)
                        return object;
                    return new $root.google.protobuf.Empty();
                };
    
                /**
                 * Creates a plain object from an Empty message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {google.protobuf.Empty} message Empty
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Empty.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this Empty to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.Empty
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Empty.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Empty;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();
    
    $root.kvrwset = (function() {
    
        /**
         * Namespace kvrwset.
         * @exports kvrwset
         * @namespace
         */
        var kvrwset = {};
    
        kvrwset.KVRWSet = (function() {
    
            /**
             * Properties of a KVRWSet.
             * @memberof kvrwset
             * @interface IKVRWSet
             * @property {Array.<kvrwset.IKVRead>|null} [reads] KVRWSet reads
             * @property {Array.<kvrwset.IRangeQueryInfo>|null} [range_queries_info] KVRWSet range_queries_info
             * @property {Array.<kvrwset.IKVWrite>|null} [writes] KVRWSet writes
             * @property {Array.<kvrwset.IKVMetadataWrite>|null} [metadata_writes] KVRWSet metadata_writes
             */
    
            /**
             * Constructs a new KVRWSet.
             * @memberof kvrwset
             * @classdesc Represents a KVRWSet.
             * @implements IKVRWSet
             * @constructor
             * @param {kvrwset.IKVRWSet=} [properties] Properties to set
             */
            function KVRWSet(properties) {
                this.reads = [];
                this.range_queries_info = [];
                this.writes = [];
                this.metadata_writes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVRWSet reads.
             * @member {Array.<kvrwset.IKVRead>} reads
             * @memberof kvrwset.KVRWSet
             * @instance
             */
            KVRWSet.prototype.reads = $util.emptyArray;
    
            /**
             * KVRWSet range_queries_info.
             * @member {Array.<kvrwset.IRangeQueryInfo>} range_queries_info
             * @memberof kvrwset.KVRWSet
             * @instance
             */
            KVRWSet.prototype.range_queries_info = $util.emptyArray;
    
            /**
             * KVRWSet writes.
             * @member {Array.<kvrwset.IKVWrite>} writes
             * @memberof kvrwset.KVRWSet
             * @instance
             */
            KVRWSet.prototype.writes = $util.emptyArray;
    
            /**
             * KVRWSet metadata_writes.
             * @member {Array.<kvrwset.IKVMetadataWrite>} metadata_writes
             * @memberof kvrwset.KVRWSet
             * @instance
             */
            KVRWSet.prototype.metadata_writes = $util.emptyArray;
    
            /**
             * Creates a new KVRWSet instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {kvrwset.IKVRWSet=} [properties] Properties to set
             * @returns {kvrwset.KVRWSet} KVRWSet instance
             */
            KVRWSet.create = function create(properties) {
                return new KVRWSet(properties);
            };
    
            /**
             * Encodes the specified KVRWSet message. Does not implicitly {@link kvrwset.KVRWSet.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {kvrwset.IKVRWSet} message KVRWSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVRWSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.reads != null && message.reads.length)
                    for (var i = 0; i < message.reads.length; ++i)
                        $root.kvrwset.KVRead.encode(message.reads[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.range_queries_info != null && message.range_queries_info.length)
                    for (var i = 0; i < message.range_queries_info.length; ++i)
                        $root.kvrwset.RangeQueryInfo.encode(message.range_queries_info[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.writes != null && message.writes.length)
                    for (var i = 0; i < message.writes.length; ++i)
                        $root.kvrwset.KVWrite.encode(message.writes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.metadata_writes != null && message.metadata_writes.length)
                    for (var i = 0; i < message.metadata_writes.length; ++i)
                        $root.kvrwset.KVMetadataWrite.encode(message.metadata_writes[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVRWSet message, length delimited. Does not implicitly {@link kvrwset.KVRWSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {kvrwset.IKVRWSet} message KVRWSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVRWSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVRWSet message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVRWSet} KVRWSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVRWSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVRWSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.reads && message.reads.length))
                            message.reads = [];
                        message.reads.push($root.kvrwset.KVRead.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.range_queries_info && message.range_queries_info.length))
                            message.range_queries_info = [];
                        message.range_queries_info.push($root.kvrwset.RangeQueryInfo.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.writes && message.writes.length))
                            message.writes = [];
                        message.writes.push($root.kvrwset.KVWrite.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.metadata_writes && message.metadata_writes.length))
                            message.metadata_writes = [];
                        message.metadata_writes.push($root.kvrwset.KVMetadataWrite.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVRWSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVRWSet} KVRWSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVRWSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVRWSet message.
             * @function verify
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVRWSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.reads != null && message.hasOwnProperty("reads")) {
                    if (!Array.isArray(message.reads))
                        return "reads: array expected";
                    for (var i = 0; i < message.reads.length; ++i) {
                        var error = $root.kvrwset.KVRead.verify(message.reads[i]);
                        if (error)
                            return "reads." + error;
                    }
                }
                if (message.range_queries_info != null && message.hasOwnProperty("range_queries_info")) {
                    if (!Array.isArray(message.range_queries_info))
                        return "range_queries_info: array expected";
                    for (var i = 0; i < message.range_queries_info.length; ++i) {
                        var error = $root.kvrwset.RangeQueryInfo.verify(message.range_queries_info[i]);
                        if (error)
                            return "range_queries_info." + error;
                    }
                }
                if (message.writes != null && message.hasOwnProperty("writes")) {
                    if (!Array.isArray(message.writes))
                        return "writes: array expected";
                    for (var i = 0; i < message.writes.length; ++i) {
                        var error = $root.kvrwset.KVWrite.verify(message.writes[i]);
                        if (error)
                            return "writes." + error;
                    }
                }
                if (message.metadata_writes != null && message.hasOwnProperty("metadata_writes")) {
                    if (!Array.isArray(message.metadata_writes))
                        return "metadata_writes: array expected";
                    for (var i = 0; i < message.metadata_writes.length; ++i) {
                        var error = $root.kvrwset.KVMetadataWrite.verify(message.metadata_writes[i]);
                        if (error)
                            return "metadata_writes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a KVRWSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVRWSet} KVRWSet
             */
            KVRWSet.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVRWSet)
                    return object;
                var message = new $root.kvrwset.KVRWSet();
                if (object.reads) {
                    if (!Array.isArray(object.reads))
                        throw TypeError(".kvrwset.KVRWSet.reads: array expected");
                    message.reads = [];
                    for (var i = 0; i < object.reads.length; ++i) {
                        if (typeof object.reads[i] !== "object")
                            throw TypeError(".kvrwset.KVRWSet.reads: object expected");
                        message.reads[i] = $root.kvrwset.KVRead.fromObject(object.reads[i]);
                    }
                }
                if (object.range_queries_info) {
                    if (!Array.isArray(object.range_queries_info))
                        throw TypeError(".kvrwset.KVRWSet.range_queries_info: array expected");
                    message.range_queries_info = [];
                    for (var i = 0; i < object.range_queries_info.length; ++i) {
                        if (typeof object.range_queries_info[i] !== "object")
                            throw TypeError(".kvrwset.KVRWSet.range_queries_info: object expected");
                        message.range_queries_info[i] = $root.kvrwset.RangeQueryInfo.fromObject(object.range_queries_info[i]);
                    }
                }
                if (object.writes) {
                    if (!Array.isArray(object.writes))
                        throw TypeError(".kvrwset.KVRWSet.writes: array expected");
                    message.writes = [];
                    for (var i = 0; i < object.writes.length; ++i) {
                        if (typeof object.writes[i] !== "object")
                            throw TypeError(".kvrwset.KVRWSet.writes: object expected");
                        message.writes[i] = $root.kvrwset.KVWrite.fromObject(object.writes[i]);
                    }
                }
                if (object.metadata_writes) {
                    if (!Array.isArray(object.metadata_writes))
                        throw TypeError(".kvrwset.KVRWSet.metadata_writes: array expected");
                    message.metadata_writes = [];
                    for (var i = 0; i < object.metadata_writes.length; ++i) {
                        if (typeof object.metadata_writes[i] !== "object")
                            throw TypeError(".kvrwset.KVRWSet.metadata_writes: object expected");
                        message.metadata_writes[i] = $root.kvrwset.KVMetadataWrite.fromObject(object.metadata_writes[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVRWSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {kvrwset.KVRWSet} message KVRWSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVRWSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.reads = [];
                    object.range_queries_info = [];
                    object.writes = [];
                    object.metadata_writes = [];
                }
                if (message.reads && message.reads.length) {
                    object.reads = [];
                    for (var j = 0; j < message.reads.length; ++j)
                        object.reads[j] = $root.kvrwset.KVRead.toObject(message.reads[j], options);
                }
                if (message.range_queries_info && message.range_queries_info.length) {
                    object.range_queries_info = [];
                    for (var j = 0; j < message.range_queries_info.length; ++j)
                        object.range_queries_info[j] = $root.kvrwset.RangeQueryInfo.toObject(message.range_queries_info[j], options);
                }
                if (message.writes && message.writes.length) {
                    object.writes = [];
                    for (var j = 0; j < message.writes.length; ++j)
                        object.writes[j] = $root.kvrwset.KVWrite.toObject(message.writes[j], options);
                }
                if (message.metadata_writes && message.metadata_writes.length) {
                    object.metadata_writes = [];
                    for (var j = 0; j < message.metadata_writes.length; ++j)
                        object.metadata_writes[j] = $root.kvrwset.KVMetadataWrite.toObject(message.metadata_writes[j], options);
                }
                return object;
            };
    
            /**
             * Converts this KVRWSet to JSON.
             * @function toJSON
             * @memberof kvrwset.KVRWSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVRWSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVRWSet;
        })();
    
        kvrwset.HashedRWSet = (function() {
    
            /**
             * Properties of a HashedRWSet.
             * @memberof kvrwset
             * @interface IHashedRWSet
             * @property {Array.<kvrwset.IKVReadHash>|null} [hashed_reads] HashedRWSet hashed_reads
             * @property {Array.<kvrwset.IKVWriteHash>|null} [hashed_writes] HashedRWSet hashed_writes
             * @property {Array.<kvrwset.IKVMetadataWriteHash>|null} [metadata_writes] HashedRWSet metadata_writes
             */
    
            /**
             * Constructs a new HashedRWSet.
             * @memberof kvrwset
             * @classdesc Represents a HashedRWSet.
             * @implements IHashedRWSet
             * @constructor
             * @param {kvrwset.IHashedRWSet=} [properties] Properties to set
             */
            function HashedRWSet(properties) {
                this.hashed_reads = [];
                this.hashed_writes = [];
                this.metadata_writes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * HashedRWSet hashed_reads.
             * @member {Array.<kvrwset.IKVReadHash>} hashed_reads
             * @memberof kvrwset.HashedRWSet
             * @instance
             */
            HashedRWSet.prototype.hashed_reads = $util.emptyArray;
    
            /**
             * HashedRWSet hashed_writes.
             * @member {Array.<kvrwset.IKVWriteHash>} hashed_writes
             * @memberof kvrwset.HashedRWSet
             * @instance
             */
            HashedRWSet.prototype.hashed_writes = $util.emptyArray;
    
            /**
             * HashedRWSet metadata_writes.
             * @member {Array.<kvrwset.IKVMetadataWriteHash>} metadata_writes
             * @memberof kvrwset.HashedRWSet
             * @instance
             */
            HashedRWSet.prototype.metadata_writes = $util.emptyArray;
    
            /**
             * Creates a new HashedRWSet instance using the specified properties.
             * @function create
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {kvrwset.IHashedRWSet=} [properties] Properties to set
             * @returns {kvrwset.HashedRWSet} HashedRWSet instance
             */
            HashedRWSet.create = function create(properties) {
                return new HashedRWSet(properties);
            };
    
            /**
             * Encodes the specified HashedRWSet message. Does not implicitly {@link kvrwset.HashedRWSet.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {kvrwset.IHashedRWSet} message HashedRWSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HashedRWSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hashed_reads != null && message.hashed_reads.length)
                    for (var i = 0; i < message.hashed_reads.length; ++i)
                        $root.kvrwset.KVReadHash.encode(message.hashed_reads[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.hashed_writes != null && message.hashed_writes.length)
                    for (var i = 0; i < message.hashed_writes.length; ++i)
                        $root.kvrwset.KVWriteHash.encode(message.hashed_writes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.metadata_writes != null && message.metadata_writes.length)
                    for (var i = 0; i < message.metadata_writes.length; ++i)
                        $root.kvrwset.KVMetadataWriteHash.encode(message.metadata_writes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified HashedRWSet message, length delimited. Does not implicitly {@link kvrwset.HashedRWSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {kvrwset.IHashedRWSet} message HashedRWSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HashedRWSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a HashedRWSet message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.HashedRWSet} HashedRWSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HashedRWSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.HashedRWSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.hashed_reads && message.hashed_reads.length))
                            message.hashed_reads = [];
                        message.hashed_reads.push($root.kvrwset.KVReadHash.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.hashed_writes && message.hashed_writes.length))
                            message.hashed_writes = [];
                        message.hashed_writes.push($root.kvrwset.KVWriteHash.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.metadata_writes && message.metadata_writes.length))
                            message.metadata_writes = [];
                        message.metadata_writes.push($root.kvrwset.KVMetadataWriteHash.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a HashedRWSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.HashedRWSet} HashedRWSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HashedRWSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a HashedRWSet message.
             * @function verify
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HashedRWSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hashed_reads != null && message.hasOwnProperty("hashed_reads")) {
                    if (!Array.isArray(message.hashed_reads))
                        return "hashed_reads: array expected";
                    for (var i = 0; i < message.hashed_reads.length; ++i) {
                        var error = $root.kvrwset.KVReadHash.verify(message.hashed_reads[i]);
                        if (error)
                            return "hashed_reads." + error;
                    }
                }
                if (message.hashed_writes != null && message.hasOwnProperty("hashed_writes")) {
                    if (!Array.isArray(message.hashed_writes))
                        return "hashed_writes: array expected";
                    for (var i = 0; i < message.hashed_writes.length; ++i) {
                        var error = $root.kvrwset.KVWriteHash.verify(message.hashed_writes[i]);
                        if (error)
                            return "hashed_writes." + error;
                    }
                }
                if (message.metadata_writes != null && message.hasOwnProperty("metadata_writes")) {
                    if (!Array.isArray(message.metadata_writes))
                        return "metadata_writes: array expected";
                    for (var i = 0; i < message.metadata_writes.length; ++i) {
                        var error = $root.kvrwset.KVMetadataWriteHash.verify(message.metadata_writes[i]);
                        if (error)
                            return "metadata_writes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a HashedRWSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.HashedRWSet} HashedRWSet
             */
            HashedRWSet.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.HashedRWSet)
                    return object;
                var message = new $root.kvrwset.HashedRWSet();
                if (object.hashed_reads) {
                    if (!Array.isArray(object.hashed_reads))
                        throw TypeError(".kvrwset.HashedRWSet.hashed_reads: array expected");
                    message.hashed_reads = [];
                    for (var i = 0; i < object.hashed_reads.length; ++i) {
                        if (typeof object.hashed_reads[i] !== "object")
                            throw TypeError(".kvrwset.HashedRWSet.hashed_reads: object expected");
                        message.hashed_reads[i] = $root.kvrwset.KVReadHash.fromObject(object.hashed_reads[i]);
                    }
                }
                if (object.hashed_writes) {
                    if (!Array.isArray(object.hashed_writes))
                        throw TypeError(".kvrwset.HashedRWSet.hashed_writes: array expected");
                    message.hashed_writes = [];
                    for (var i = 0; i < object.hashed_writes.length; ++i) {
                        if (typeof object.hashed_writes[i] !== "object")
                            throw TypeError(".kvrwset.HashedRWSet.hashed_writes: object expected");
                        message.hashed_writes[i] = $root.kvrwset.KVWriteHash.fromObject(object.hashed_writes[i]);
                    }
                }
                if (object.metadata_writes) {
                    if (!Array.isArray(object.metadata_writes))
                        throw TypeError(".kvrwset.HashedRWSet.metadata_writes: array expected");
                    message.metadata_writes = [];
                    for (var i = 0; i < object.metadata_writes.length; ++i) {
                        if (typeof object.metadata_writes[i] !== "object")
                            throw TypeError(".kvrwset.HashedRWSet.metadata_writes: object expected");
                        message.metadata_writes[i] = $root.kvrwset.KVMetadataWriteHash.fromObject(object.metadata_writes[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a HashedRWSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {kvrwset.HashedRWSet} message HashedRWSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HashedRWSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.hashed_reads = [];
                    object.hashed_writes = [];
                    object.metadata_writes = [];
                }
                if (message.hashed_reads && message.hashed_reads.length) {
                    object.hashed_reads = [];
                    for (var j = 0; j < message.hashed_reads.length; ++j)
                        object.hashed_reads[j] = $root.kvrwset.KVReadHash.toObject(message.hashed_reads[j], options);
                }
                if (message.hashed_writes && message.hashed_writes.length) {
                    object.hashed_writes = [];
                    for (var j = 0; j < message.hashed_writes.length; ++j)
                        object.hashed_writes[j] = $root.kvrwset.KVWriteHash.toObject(message.hashed_writes[j], options);
                }
                if (message.metadata_writes && message.metadata_writes.length) {
                    object.metadata_writes = [];
                    for (var j = 0; j < message.metadata_writes.length; ++j)
                        object.metadata_writes[j] = $root.kvrwset.KVMetadataWriteHash.toObject(message.metadata_writes[j], options);
                }
                return object;
            };
    
            /**
             * Converts this HashedRWSet to JSON.
             * @function toJSON
             * @memberof kvrwset.HashedRWSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HashedRWSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return HashedRWSet;
        })();
    
        kvrwset.KVRead = (function() {
    
            /**
             * Properties of a KVRead.
             * @memberof kvrwset
             * @interface IKVRead
             * @property {string|null} [key] KVRead key
             * @property {kvrwset.IVersion|null} [version] KVRead version
             */
    
            /**
             * Constructs a new KVRead.
             * @memberof kvrwset
             * @classdesc Represents a KVRead.
             * @implements IKVRead
             * @constructor
             * @param {kvrwset.IKVRead=} [properties] Properties to set
             */
            function KVRead(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVRead key.
             * @member {string} key
             * @memberof kvrwset.KVRead
             * @instance
             */
            KVRead.prototype.key = "";
    
            /**
             * KVRead version.
             * @member {kvrwset.IVersion|null|undefined} version
             * @memberof kvrwset.KVRead
             * @instance
             */
            KVRead.prototype.version = null;
    
            /**
             * Creates a new KVRead instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVRead
             * @static
             * @param {kvrwset.IKVRead=} [properties] Properties to set
             * @returns {kvrwset.KVRead} KVRead instance
             */
            KVRead.create = function create(properties) {
                return new KVRead(properties);
            };
    
            /**
             * Encodes the specified KVRead message. Does not implicitly {@link kvrwset.KVRead.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVRead
             * @static
             * @param {kvrwset.IKVRead} message KVRead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVRead.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    $root.kvrwset.Version.encode(message.version, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVRead message, length delimited. Does not implicitly {@link kvrwset.KVRead.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVRead
             * @static
             * @param {kvrwset.IKVRead} message KVRead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVRead.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVRead message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVRead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVRead} KVRead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVRead.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVRead();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.version = $root.kvrwset.Version.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVRead message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVRead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVRead} KVRead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVRead.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVRead message.
             * @function verify
             * @memberof kvrwset.KVRead
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVRead.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.version != null && message.hasOwnProperty("version")) {
                    var error = $root.kvrwset.Version.verify(message.version);
                    if (error)
                        return "version." + error;
                }
                return null;
            };
    
            /**
             * Creates a KVRead message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVRead
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVRead} KVRead
             */
            KVRead.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVRead)
                    return object;
                var message = new $root.kvrwset.KVRead();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.version != null) {
                    if (typeof object.version !== "object")
                        throw TypeError(".kvrwset.KVRead.version: object expected");
                    message.version = $root.kvrwset.Version.fromObject(object.version);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVRead message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVRead
             * @static
             * @param {kvrwset.KVRead} message KVRead
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVRead.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.version = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = $root.kvrwset.Version.toObject(message.version, options);
                return object;
            };
    
            /**
             * Converts this KVRead to JSON.
             * @function toJSON
             * @memberof kvrwset.KVRead
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVRead.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVRead;
        })();
    
        kvrwset.KVWrite = (function() {
    
            /**
             * Properties of a KVWrite.
             * @memberof kvrwset
             * @interface IKVWrite
             * @property {string|null} [key] KVWrite key
             * @property {boolean|null} [is_delete] KVWrite is_delete
             * @property {Uint8Array|null} [value] KVWrite value
             */
    
            /**
             * Constructs a new KVWrite.
             * @memberof kvrwset
             * @classdesc Represents a KVWrite.
             * @implements IKVWrite
             * @constructor
             * @param {kvrwset.IKVWrite=} [properties] Properties to set
             */
            function KVWrite(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVWrite key.
             * @member {string} key
             * @memberof kvrwset.KVWrite
             * @instance
             */
            KVWrite.prototype.key = "";
    
            /**
             * KVWrite is_delete.
             * @member {boolean} is_delete
             * @memberof kvrwset.KVWrite
             * @instance
             */
            KVWrite.prototype.is_delete = false;
    
            /**
             * KVWrite value.
             * @member {Uint8Array} value
             * @memberof kvrwset.KVWrite
             * @instance
             */
            KVWrite.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new KVWrite instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVWrite
             * @static
             * @param {kvrwset.IKVWrite=} [properties] Properties to set
             * @returns {kvrwset.KVWrite} KVWrite instance
             */
            KVWrite.create = function create(properties) {
                return new KVWrite(properties);
            };
    
            /**
             * Encodes the specified KVWrite message. Does not implicitly {@link kvrwset.KVWrite.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVWrite
             * @static
             * @param {kvrwset.IKVWrite} message KVWrite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVWrite.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.is_delete != null && Object.hasOwnProperty.call(message, "is_delete"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_delete);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified KVWrite message, length delimited. Does not implicitly {@link kvrwset.KVWrite.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVWrite
             * @static
             * @param {kvrwset.IKVWrite} message KVWrite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVWrite.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVWrite message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVWrite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVWrite} KVWrite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVWrite.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVWrite();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.is_delete = reader.bool();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVWrite message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVWrite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVWrite} KVWrite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVWrite.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVWrite message.
             * @function verify
             * @memberof kvrwset.KVWrite
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVWrite.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.is_delete != null && message.hasOwnProperty("is_delete"))
                    if (typeof message.is_delete !== "boolean")
                        return "is_delete: boolean expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a KVWrite message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVWrite
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVWrite} KVWrite
             */
            KVWrite.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVWrite)
                    return object;
                var message = new $root.kvrwset.KVWrite();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.is_delete != null)
                    message.is_delete = Boolean(object.is_delete);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a KVWrite message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVWrite
             * @static
             * @param {kvrwset.KVWrite} message KVWrite
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVWrite.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.is_delete = false;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.is_delete != null && message.hasOwnProperty("is_delete"))
                    object.is_delete = message.is_delete;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this KVWrite to JSON.
             * @function toJSON
             * @memberof kvrwset.KVWrite
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVWrite.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVWrite;
        })();
    
        kvrwset.KVMetadataWrite = (function() {
    
            /**
             * Properties of a KVMetadataWrite.
             * @memberof kvrwset
             * @interface IKVMetadataWrite
             * @property {string|null} [key] KVMetadataWrite key
             * @property {Array.<kvrwset.IKVMetadataEntry>|null} [entries] KVMetadataWrite entries
             */
    
            /**
             * Constructs a new KVMetadataWrite.
             * @memberof kvrwset
             * @classdesc Represents a KVMetadataWrite.
             * @implements IKVMetadataWrite
             * @constructor
             * @param {kvrwset.IKVMetadataWrite=} [properties] Properties to set
             */
            function KVMetadataWrite(properties) {
                this.entries = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVMetadataWrite key.
             * @member {string} key
             * @memberof kvrwset.KVMetadataWrite
             * @instance
             */
            KVMetadataWrite.prototype.key = "";
    
            /**
             * KVMetadataWrite entries.
             * @member {Array.<kvrwset.IKVMetadataEntry>} entries
             * @memberof kvrwset.KVMetadataWrite
             * @instance
             */
            KVMetadataWrite.prototype.entries = $util.emptyArray;
    
            /**
             * Creates a new KVMetadataWrite instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {kvrwset.IKVMetadataWrite=} [properties] Properties to set
             * @returns {kvrwset.KVMetadataWrite} KVMetadataWrite instance
             */
            KVMetadataWrite.create = function create(properties) {
                return new KVMetadataWrite(properties);
            };
    
            /**
             * Encodes the specified KVMetadataWrite message. Does not implicitly {@link kvrwset.KVMetadataWrite.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {kvrwset.IKVMetadataWrite} message KVMetadataWrite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataWrite.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.entries != null && message.entries.length)
                    for (var i = 0; i < message.entries.length; ++i)
                        $root.kvrwset.KVMetadataEntry.encode(message.entries[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVMetadataWrite message, length delimited. Does not implicitly {@link kvrwset.KVMetadataWrite.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {kvrwset.IKVMetadataWrite} message KVMetadataWrite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataWrite.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVMetadataWrite message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVMetadataWrite} KVMetadataWrite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataWrite.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVMetadataWrite();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        if (!(message.entries && message.entries.length))
                            message.entries = [];
                        message.entries.push($root.kvrwset.KVMetadataEntry.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVMetadataWrite message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVMetadataWrite} KVMetadataWrite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataWrite.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVMetadataWrite message.
             * @function verify
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVMetadataWrite.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.entries != null && message.hasOwnProperty("entries")) {
                    if (!Array.isArray(message.entries))
                        return "entries: array expected";
                    for (var i = 0; i < message.entries.length; ++i) {
                        var error = $root.kvrwset.KVMetadataEntry.verify(message.entries[i]);
                        if (error)
                            return "entries." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a KVMetadataWrite message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVMetadataWrite} KVMetadataWrite
             */
            KVMetadataWrite.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVMetadataWrite)
                    return object;
                var message = new $root.kvrwset.KVMetadataWrite();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.entries) {
                    if (!Array.isArray(object.entries))
                        throw TypeError(".kvrwset.KVMetadataWrite.entries: array expected");
                    message.entries = [];
                    for (var i = 0; i < object.entries.length; ++i) {
                        if (typeof object.entries[i] !== "object")
                            throw TypeError(".kvrwset.KVMetadataWrite.entries: object expected");
                        message.entries[i] = $root.kvrwset.KVMetadataEntry.fromObject(object.entries[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVMetadataWrite message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {kvrwset.KVMetadataWrite} message KVMetadataWrite
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVMetadataWrite.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.entries = [];
                if (options.defaults)
                    object.key = "";
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.entries && message.entries.length) {
                    object.entries = [];
                    for (var j = 0; j < message.entries.length; ++j)
                        object.entries[j] = $root.kvrwset.KVMetadataEntry.toObject(message.entries[j], options);
                }
                return object;
            };
    
            /**
             * Converts this KVMetadataWrite to JSON.
             * @function toJSON
             * @memberof kvrwset.KVMetadataWrite
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVMetadataWrite.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVMetadataWrite;
        })();
    
        kvrwset.KVReadHash = (function() {
    
            /**
             * Properties of a KVReadHash.
             * @memberof kvrwset
             * @interface IKVReadHash
             * @property {Uint8Array|null} [key_hash] KVReadHash key_hash
             * @property {kvrwset.IVersion|null} [version] KVReadHash version
             */
    
            /**
             * Constructs a new KVReadHash.
             * @memberof kvrwset
             * @classdesc Represents a KVReadHash.
             * @implements IKVReadHash
             * @constructor
             * @param {kvrwset.IKVReadHash=} [properties] Properties to set
             */
            function KVReadHash(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVReadHash key_hash.
             * @member {Uint8Array} key_hash
             * @memberof kvrwset.KVReadHash
             * @instance
             */
            KVReadHash.prototype.key_hash = $util.newBuffer([]);
    
            /**
             * KVReadHash version.
             * @member {kvrwset.IVersion|null|undefined} version
             * @memberof kvrwset.KVReadHash
             * @instance
             */
            KVReadHash.prototype.version = null;
    
            /**
             * Creates a new KVReadHash instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {kvrwset.IKVReadHash=} [properties] Properties to set
             * @returns {kvrwset.KVReadHash} KVReadHash instance
             */
            KVReadHash.create = function create(properties) {
                return new KVReadHash(properties);
            };
    
            /**
             * Encodes the specified KVReadHash message. Does not implicitly {@link kvrwset.KVReadHash.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {kvrwset.IKVReadHash} message KVReadHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVReadHash.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key_hash != null && Object.hasOwnProperty.call(message, "key_hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key_hash);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    $root.kvrwset.Version.encode(message.version, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVReadHash message, length delimited. Does not implicitly {@link kvrwset.KVReadHash.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {kvrwset.IKVReadHash} message KVReadHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVReadHash.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVReadHash message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVReadHash} KVReadHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVReadHash.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVReadHash();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key_hash = reader.bytes();
                        break;
                    case 2:
                        message.version = $root.kvrwset.Version.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVReadHash message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVReadHash} KVReadHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVReadHash.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVReadHash message.
             * @function verify
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVReadHash.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key_hash != null && message.hasOwnProperty("key_hash"))
                    if (!(message.key_hash && typeof message.key_hash.length === "number" || $util.isString(message.key_hash)))
                        return "key_hash: buffer expected";
                if (message.version != null && message.hasOwnProperty("version")) {
                    var error = $root.kvrwset.Version.verify(message.version);
                    if (error)
                        return "version." + error;
                }
                return null;
            };
    
            /**
             * Creates a KVReadHash message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVReadHash} KVReadHash
             */
            KVReadHash.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVReadHash)
                    return object;
                var message = new $root.kvrwset.KVReadHash();
                if (object.key_hash != null)
                    if (typeof object.key_hash === "string")
                        $util.base64.decode(object.key_hash, message.key_hash = $util.newBuffer($util.base64.length(object.key_hash)), 0);
                    else if (object.key_hash.length)
                        message.key_hash = object.key_hash;
                if (object.version != null) {
                    if (typeof object.version !== "object")
                        throw TypeError(".kvrwset.KVReadHash.version: object expected");
                    message.version = $root.kvrwset.Version.fromObject(object.version);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVReadHash message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {kvrwset.KVReadHash} message KVReadHash
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVReadHash.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.key_hash = "";
                    else {
                        object.key_hash = [];
                        if (options.bytes !== Array)
                            object.key_hash = $util.newBuffer(object.key_hash);
                    }
                    object.version = null;
                }
                if (message.key_hash != null && message.hasOwnProperty("key_hash"))
                    object.key_hash = options.bytes === String ? $util.base64.encode(message.key_hash, 0, message.key_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.key_hash) : message.key_hash;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = $root.kvrwset.Version.toObject(message.version, options);
                return object;
            };
    
            /**
             * Converts this KVReadHash to JSON.
             * @function toJSON
             * @memberof kvrwset.KVReadHash
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVReadHash.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVReadHash;
        })();
    
        kvrwset.KVWriteHash = (function() {
    
            /**
             * Properties of a KVWriteHash.
             * @memberof kvrwset
             * @interface IKVWriteHash
             * @property {Uint8Array|null} [key_hash] KVWriteHash key_hash
             * @property {boolean|null} [is_delete] KVWriteHash is_delete
             * @property {Uint8Array|null} [value_hash] KVWriteHash value_hash
             */
    
            /**
             * Constructs a new KVWriteHash.
             * @memberof kvrwset
             * @classdesc Represents a KVWriteHash.
             * @implements IKVWriteHash
             * @constructor
             * @param {kvrwset.IKVWriteHash=} [properties] Properties to set
             */
            function KVWriteHash(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVWriteHash key_hash.
             * @member {Uint8Array} key_hash
             * @memberof kvrwset.KVWriteHash
             * @instance
             */
            KVWriteHash.prototype.key_hash = $util.newBuffer([]);
    
            /**
             * KVWriteHash is_delete.
             * @member {boolean} is_delete
             * @memberof kvrwset.KVWriteHash
             * @instance
             */
            KVWriteHash.prototype.is_delete = false;
    
            /**
             * KVWriteHash value_hash.
             * @member {Uint8Array} value_hash
             * @memberof kvrwset.KVWriteHash
             * @instance
             */
            KVWriteHash.prototype.value_hash = $util.newBuffer([]);
    
            /**
             * Creates a new KVWriteHash instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {kvrwset.IKVWriteHash=} [properties] Properties to set
             * @returns {kvrwset.KVWriteHash} KVWriteHash instance
             */
            KVWriteHash.create = function create(properties) {
                return new KVWriteHash(properties);
            };
    
            /**
             * Encodes the specified KVWriteHash message. Does not implicitly {@link kvrwset.KVWriteHash.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {kvrwset.IKVWriteHash} message KVWriteHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVWriteHash.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key_hash != null && Object.hasOwnProperty.call(message, "key_hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key_hash);
                if (message.is_delete != null && Object.hasOwnProperty.call(message, "is_delete"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_delete);
                if (message.value_hash != null && Object.hasOwnProperty.call(message, "value_hash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value_hash);
                return writer;
            };
    
            /**
             * Encodes the specified KVWriteHash message, length delimited. Does not implicitly {@link kvrwset.KVWriteHash.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {kvrwset.IKVWriteHash} message KVWriteHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVWriteHash.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVWriteHash message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVWriteHash} KVWriteHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVWriteHash.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVWriteHash();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key_hash = reader.bytes();
                        break;
                    case 2:
                        message.is_delete = reader.bool();
                        break;
                    case 3:
                        message.value_hash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVWriteHash message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVWriteHash} KVWriteHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVWriteHash.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVWriteHash message.
             * @function verify
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVWriteHash.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key_hash != null && message.hasOwnProperty("key_hash"))
                    if (!(message.key_hash && typeof message.key_hash.length === "number" || $util.isString(message.key_hash)))
                        return "key_hash: buffer expected";
                if (message.is_delete != null && message.hasOwnProperty("is_delete"))
                    if (typeof message.is_delete !== "boolean")
                        return "is_delete: boolean expected";
                if (message.value_hash != null && message.hasOwnProperty("value_hash"))
                    if (!(message.value_hash && typeof message.value_hash.length === "number" || $util.isString(message.value_hash)))
                        return "value_hash: buffer expected";
                return null;
            };
    
            /**
             * Creates a KVWriteHash message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVWriteHash} KVWriteHash
             */
            KVWriteHash.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVWriteHash)
                    return object;
                var message = new $root.kvrwset.KVWriteHash();
                if (object.key_hash != null)
                    if (typeof object.key_hash === "string")
                        $util.base64.decode(object.key_hash, message.key_hash = $util.newBuffer($util.base64.length(object.key_hash)), 0);
                    else if (object.key_hash.length)
                        message.key_hash = object.key_hash;
                if (object.is_delete != null)
                    message.is_delete = Boolean(object.is_delete);
                if (object.value_hash != null)
                    if (typeof object.value_hash === "string")
                        $util.base64.decode(object.value_hash, message.value_hash = $util.newBuffer($util.base64.length(object.value_hash)), 0);
                    else if (object.value_hash.length)
                        message.value_hash = object.value_hash;
                return message;
            };
    
            /**
             * Creates a plain object from a KVWriteHash message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {kvrwset.KVWriteHash} message KVWriteHash
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVWriteHash.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.key_hash = "";
                    else {
                        object.key_hash = [];
                        if (options.bytes !== Array)
                            object.key_hash = $util.newBuffer(object.key_hash);
                    }
                    object.is_delete = false;
                    if (options.bytes === String)
                        object.value_hash = "";
                    else {
                        object.value_hash = [];
                        if (options.bytes !== Array)
                            object.value_hash = $util.newBuffer(object.value_hash);
                    }
                }
                if (message.key_hash != null && message.hasOwnProperty("key_hash"))
                    object.key_hash = options.bytes === String ? $util.base64.encode(message.key_hash, 0, message.key_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.key_hash) : message.key_hash;
                if (message.is_delete != null && message.hasOwnProperty("is_delete"))
                    object.is_delete = message.is_delete;
                if (message.value_hash != null && message.hasOwnProperty("value_hash"))
                    object.value_hash = options.bytes === String ? $util.base64.encode(message.value_hash, 0, message.value_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.value_hash) : message.value_hash;
                return object;
            };
    
            /**
             * Converts this KVWriteHash to JSON.
             * @function toJSON
             * @memberof kvrwset.KVWriteHash
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVWriteHash.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVWriteHash;
        })();
    
        kvrwset.KVMetadataWriteHash = (function() {
    
            /**
             * Properties of a KVMetadataWriteHash.
             * @memberof kvrwset
             * @interface IKVMetadataWriteHash
             * @property {Uint8Array|null} [key_hash] KVMetadataWriteHash key_hash
             * @property {Array.<kvrwset.IKVMetadataEntry>|null} [entries] KVMetadataWriteHash entries
             */
    
            /**
             * Constructs a new KVMetadataWriteHash.
             * @memberof kvrwset
             * @classdesc Represents a KVMetadataWriteHash.
             * @implements IKVMetadataWriteHash
             * @constructor
             * @param {kvrwset.IKVMetadataWriteHash=} [properties] Properties to set
             */
            function KVMetadataWriteHash(properties) {
                this.entries = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVMetadataWriteHash key_hash.
             * @member {Uint8Array} key_hash
             * @memberof kvrwset.KVMetadataWriteHash
             * @instance
             */
            KVMetadataWriteHash.prototype.key_hash = $util.newBuffer([]);
    
            /**
             * KVMetadataWriteHash entries.
             * @member {Array.<kvrwset.IKVMetadataEntry>} entries
             * @memberof kvrwset.KVMetadataWriteHash
             * @instance
             */
            KVMetadataWriteHash.prototype.entries = $util.emptyArray;
    
            /**
             * Creates a new KVMetadataWriteHash instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {kvrwset.IKVMetadataWriteHash=} [properties] Properties to set
             * @returns {kvrwset.KVMetadataWriteHash} KVMetadataWriteHash instance
             */
            KVMetadataWriteHash.create = function create(properties) {
                return new KVMetadataWriteHash(properties);
            };
    
            /**
             * Encodes the specified KVMetadataWriteHash message. Does not implicitly {@link kvrwset.KVMetadataWriteHash.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {kvrwset.IKVMetadataWriteHash} message KVMetadataWriteHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataWriteHash.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key_hash != null && Object.hasOwnProperty.call(message, "key_hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key_hash);
                if (message.entries != null && message.entries.length)
                    for (var i = 0; i < message.entries.length; ++i)
                        $root.kvrwset.KVMetadataEntry.encode(message.entries[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVMetadataWriteHash message, length delimited. Does not implicitly {@link kvrwset.KVMetadataWriteHash.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {kvrwset.IKVMetadataWriteHash} message KVMetadataWriteHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataWriteHash.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVMetadataWriteHash message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVMetadataWriteHash} KVMetadataWriteHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataWriteHash.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVMetadataWriteHash();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key_hash = reader.bytes();
                        break;
                    case 2:
                        if (!(message.entries && message.entries.length))
                            message.entries = [];
                        message.entries.push($root.kvrwset.KVMetadataEntry.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVMetadataWriteHash message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVMetadataWriteHash} KVMetadataWriteHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataWriteHash.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVMetadataWriteHash message.
             * @function verify
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVMetadataWriteHash.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key_hash != null && message.hasOwnProperty("key_hash"))
                    if (!(message.key_hash && typeof message.key_hash.length === "number" || $util.isString(message.key_hash)))
                        return "key_hash: buffer expected";
                if (message.entries != null && message.hasOwnProperty("entries")) {
                    if (!Array.isArray(message.entries))
                        return "entries: array expected";
                    for (var i = 0; i < message.entries.length; ++i) {
                        var error = $root.kvrwset.KVMetadataEntry.verify(message.entries[i]);
                        if (error)
                            return "entries." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a KVMetadataWriteHash message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVMetadataWriteHash} KVMetadataWriteHash
             */
            KVMetadataWriteHash.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVMetadataWriteHash)
                    return object;
                var message = new $root.kvrwset.KVMetadataWriteHash();
                if (object.key_hash != null)
                    if (typeof object.key_hash === "string")
                        $util.base64.decode(object.key_hash, message.key_hash = $util.newBuffer($util.base64.length(object.key_hash)), 0);
                    else if (object.key_hash.length)
                        message.key_hash = object.key_hash;
                if (object.entries) {
                    if (!Array.isArray(object.entries))
                        throw TypeError(".kvrwset.KVMetadataWriteHash.entries: array expected");
                    message.entries = [];
                    for (var i = 0; i < object.entries.length; ++i) {
                        if (typeof object.entries[i] !== "object")
                            throw TypeError(".kvrwset.KVMetadataWriteHash.entries: object expected");
                        message.entries[i] = $root.kvrwset.KVMetadataEntry.fromObject(object.entries[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVMetadataWriteHash message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {kvrwset.KVMetadataWriteHash} message KVMetadataWriteHash
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVMetadataWriteHash.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.entries = [];
                if (options.defaults)
                    if (options.bytes === String)
                        object.key_hash = "";
                    else {
                        object.key_hash = [];
                        if (options.bytes !== Array)
                            object.key_hash = $util.newBuffer(object.key_hash);
                    }
                if (message.key_hash != null && message.hasOwnProperty("key_hash"))
                    object.key_hash = options.bytes === String ? $util.base64.encode(message.key_hash, 0, message.key_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.key_hash) : message.key_hash;
                if (message.entries && message.entries.length) {
                    object.entries = [];
                    for (var j = 0; j < message.entries.length; ++j)
                        object.entries[j] = $root.kvrwset.KVMetadataEntry.toObject(message.entries[j], options);
                }
                return object;
            };
    
            /**
             * Converts this KVMetadataWriteHash to JSON.
             * @function toJSON
             * @memberof kvrwset.KVMetadataWriteHash
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVMetadataWriteHash.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVMetadataWriteHash;
        })();
    
        kvrwset.KVMetadataEntry = (function() {
    
            /**
             * Properties of a KVMetadataEntry.
             * @memberof kvrwset
             * @interface IKVMetadataEntry
             * @property {string|null} [name] KVMetadataEntry name
             * @property {Uint8Array|null} [value] KVMetadataEntry value
             */
    
            /**
             * Constructs a new KVMetadataEntry.
             * @memberof kvrwset
             * @classdesc Represents a KVMetadataEntry.
             * @implements IKVMetadataEntry
             * @constructor
             * @param {kvrwset.IKVMetadataEntry=} [properties] Properties to set
             */
            function KVMetadataEntry(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVMetadataEntry name.
             * @member {string} name
             * @memberof kvrwset.KVMetadataEntry
             * @instance
             */
            KVMetadataEntry.prototype.name = "";
    
            /**
             * KVMetadataEntry value.
             * @member {Uint8Array} value
             * @memberof kvrwset.KVMetadataEntry
             * @instance
             */
            KVMetadataEntry.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new KVMetadataEntry instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {kvrwset.IKVMetadataEntry=} [properties] Properties to set
             * @returns {kvrwset.KVMetadataEntry} KVMetadataEntry instance
             */
            KVMetadataEntry.create = function create(properties) {
                return new KVMetadataEntry(properties);
            };
    
            /**
             * Encodes the specified KVMetadataEntry message. Does not implicitly {@link kvrwset.KVMetadataEntry.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {kvrwset.IKVMetadataEntry} message KVMetadataEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified KVMetadataEntry message, length delimited. Does not implicitly {@link kvrwset.KVMetadataEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {kvrwset.IKVMetadataEntry} message KVMetadataEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVMetadataEntry message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVMetadataEntry} KVMetadataEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVMetadataEntry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVMetadataEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVMetadataEntry} KVMetadataEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVMetadataEntry message.
             * @function verify
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVMetadataEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a KVMetadataEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVMetadataEntry} KVMetadataEntry
             */
            KVMetadataEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVMetadataEntry)
                    return object;
                var message = new $root.kvrwset.KVMetadataEntry();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a KVMetadataEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {kvrwset.KVMetadataEntry} message KVMetadataEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVMetadataEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this KVMetadataEntry to JSON.
             * @function toJSON
             * @memberof kvrwset.KVMetadataEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVMetadataEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVMetadataEntry;
        })();
    
        kvrwset.Version = (function() {
    
            /**
             * Properties of a Version.
             * @memberof kvrwset
             * @interface IVersion
             * @property {number|Long|null} [block_num] Version block_num
             * @property {number|Long|null} [tx_num] Version tx_num
             */
    
            /**
             * Constructs a new Version.
             * @memberof kvrwset
             * @classdesc Represents a Version.
             * @implements IVersion
             * @constructor
             * @param {kvrwset.IVersion=} [properties] Properties to set
             */
            function Version(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Version block_num.
             * @member {number|Long} block_num
             * @memberof kvrwset.Version
             * @instance
             */
            Version.prototype.block_num = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Version tx_num.
             * @member {number|Long} tx_num
             * @memberof kvrwset.Version
             * @instance
             */
            Version.prototype.tx_num = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new Version instance using the specified properties.
             * @function create
             * @memberof kvrwset.Version
             * @static
             * @param {kvrwset.IVersion=} [properties] Properties to set
             * @returns {kvrwset.Version} Version instance
             */
            Version.create = function create(properties) {
                return new Version(properties);
            };
    
            /**
             * Encodes the specified Version message. Does not implicitly {@link kvrwset.Version.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.Version
             * @static
             * @param {kvrwset.IVersion} message Version message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Version.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.block_num != null && Object.hasOwnProperty.call(message, "block_num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.block_num);
                if (message.tx_num != null && Object.hasOwnProperty.call(message, "tx_num"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.tx_num);
                return writer;
            };
    
            /**
             * Encodes the specified Version message, length delimited. Does not implicitly {@link kvrwset.Version.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.Version
             * @static
             * @param {kvrwset.IVersion} message Version message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Version.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Version message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.Version
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.Version} Version
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Version.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.Version();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.block_num = reader.uint64();
                        break;
                    case 2:
                        message.tx_num = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Version message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.Version
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.Version} Version
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Version.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Version message.
             * @function verify
             * @memberof kvrwset.Version
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Version.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.block_num != null && message.hasOwnProperty("block_num"))
                    if (!$util.isInteger(message.block_num) && !(message.block_num && $util.isInteger(message.block_num.low) && $util.isInteger(message.block_num.high)))
                        return "block_num: integer|Long expected";
                if (message.tx_num != null && message.hasOwnProperty("tx_num"))
                    if (!$util.isInteger(message.tx_num) && !(message.tx_num && $util.isInteger(message.tx_num.low) && $util.isInteger(message.tx_num.high)))
                        return "tx_num: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a Version message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.Version
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.Version} Version
             */
            Version.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.Version)
                    return object;
                var message = new $root.kvrwset.Version();
                if (object.block_num != null)
                    if ($util.Long)
                        (message.block_num = $util.Long.fromValue(object.block_num)).unsigned = true;
                    else if (typeof object.block_num === "string")
                        message.block_num = parseInt(object.block_num, 10);
                    else if (typeof object.block_num === "number")
                        message.block_num = object.block_num;
                    else if (typeof object.block_num === "object")
                        message.block_num = new $util.LongBits(object.block_num.low >>> 0, object.block_num.high >>> 0).toNumber(true);
                if (object.tx_num != null)
                    if ($util.Long)
                        (message.tx_num = $util.Long.fromValue(object.tx_num)).unsigned = true;
                    else if (typeof object.tx_num === "string")
                        message.tx_num = parseInt(object.tx_num, 10);
                    else if (typeof object.tx_num === "number")
                        message.tx_num = object.tx_num;
                    else if (typeof object.tx_num === "object")
                        message.tx_num = new $util.LongBits(object.tx_num.low >>> 0, object.tx_num.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a Version message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.Version
             * @static
             * @param {kvrwset.Version} message Version
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Version.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.block_num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block_num = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.tx_num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tx_num = options.longs === String ? "0" : 0;
                }
                if (message.block_num != null && message.hasOwnProperty("block_num"))
                    if (typeof message.block_num === "number")
                        object.block_num = options.longs === String ? String(message.block_num) : message.block_num;
                    else
                        object.block_num = options.longs === String ? $util.Long.prototype.toString.call(message.block_num) : options.longs === Number ? new $util.LongBits(message.block_num.low >>> 0, message.block_num.high >>> 0).toNumber(true) : message.block_num;
                if (message.tx_num != null && message.hasOwnProperty("tx_num"))
                    if (typeof message.tx_num === "number")
                        object.tx_num = options.longs === String ? String(message.tx_num) : message.tx_num;
                    else
                        object.tx_num = options.longs === String ? $util.Long.prototype.toString.call(message.tx_num) : options.longs === Number ? new $util.LongBits(message.tx_num.low >>> 0, message.tx_num.high >>> 0).toNumber(true) : message.tx_num;
                return object;
            };
    
            /**
             * Converts this Version to JSON.
             * @function toJSON
             * @memberof kvrwset.Version
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Version.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Version;
        })();
    
        kvrwset.RangeQueryInfo = (function() {
    
            /**
             * Properties of a RangeQueryInfo.
             * @memberof kvrwset
             * @interface IRangeQueryInfo
             * @property {string|null} [start_key] RangeQueryInfo start_key
             * @property {string|null} [end_key] RangeQueryInfo end_key
             * @property {boolean|null} [itr_exhausted] RangeQueryInfo itr_exhausted
             * @property {kvrwset.IQueryReads|null} [raw_reads] RangeQueryInfo raw_reads
             * @property {kvrwset.IQueryReadsMerkleSummary|null} [reads_merkle_hashes] RangeQueryInfo reads_merkle_hashes
             */
    
            /**
             * Constructs a new RangeQueryInfo.
             * @memberof kvrwset
             * @classdesc Represents a RangeQueryInfo.
             * @implements IRangeQueryInfo
             * @constructor
             * @param {kvrwset.IRangeQueryInfo=} [properties] Properties to set
             */
            function RangeQueryInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RangeQueryInfo start_key.
             * @member {string} start_key
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.start_key = "";
    
            /**
             * RangeQueryInfo end_key.
             * @member {string} end_key
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.end_key = "";
    
            /**
             * RangeQueryInfo itr_exhausted.
             * @member {boolean} itr_exhausted
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.itr_exhausted = false;
    
            /**
             * RangeQueryInfo raw_reads.
             * @member {kvrwset.IQueryReads|null|undefined} raw_reads
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.raw_reads = null;
    
            /**
             * RangeQueryInfo reads_merkle_hashes.
             * @member {kvrwset.IQueryReadsMerkleSummary|null|undefined} reads_merkle_hashes
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.reads_merkle_hashes = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * RangeQueryInfo reads_info.
             * @member {"raw_reads"|"reads_merkle_hashes"|undefined} reads_info
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            Object.defineProperty(RangeQueryInfo.prototype, "reads_info", {
                get: $util.oneOfGetter($oneOfFields = ["raw_reads", "reads_merkle_hashes"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new RangeQueryInfo instance using the specified properties.
             * @function create
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {kvrwset.IRangeQueryInfo=} [properties] Properties to set
             * @returns {kvrwset.RangeQueryInfo} RangeQueryInfo instance
             */
            RangeQueryInfo.create = function create(properties) {
                return new RangeQueryInfo(properties);
            };
    
            /**
             * Encodes the specified RangeQueryInfo message. Does not implicitly {@link kvrwset.RangeQueryInfo.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {kvrwset.IRangeQueryInfo} message RangeQueryInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RangeQueryInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start_key != null && Object.hasOwnProperty.call(message, "start_key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.start_key);
                if (message.end_key != null && Object.hasOwnProperty.call(message, "end_key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.end_key);
                if (message.itr_exhausted != null && Object.hasOwnProperty.call(message, "itr_exhausted"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.itr_exhausted);
                if (message.raw_reads != null && Object.hasOwnProperty.call(message, "raw_reads"))
                    $root.kvrwset.QueryReads.encode(message.raw_reads, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.reads_merkle_hashes != null && Object.hasOwnProperty.call(message, "reads_merkle_hashes"))
                    $root.kvrwset.QueryReadsMerkleSummary.encode(message.reads_merkle_hashes, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified RangeQueryInfo message, length delimited. Does not implicitly {@link kvrwset.RangeQueryInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {kvrwset.IRangeQueryInfo} message RangeQueryInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RangeQueryInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RangeQueryInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.RangeQueryInfo} RangeQueryInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RangeQueryInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.RangeQueryInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.start_key = reader.string();
                        break;
                    case 2:
                        message.end_key = reader.string();
                        break;
                    case 3:
                        message.itr_exhausted = reader.bool();
                        break;
                    case 4:
                        message.raw_reads = $root.kvrwset.QueryReads.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.reads_merkle_hashes = $root.kvrwset.QueryReadsMerkleSummary.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RangeQueryInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.RangeQueryInfo} RangeQueryInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RangeQueryInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RangeQueryInfo message.
             * @function verify
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RangeQueryInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.start_key != null && message.hasOwnProperty("start_key"))
                    if (!$util.isString(message.start_key))
                        return "start_key: string expected";
                if (message.end_key != null && message.hasOwnProperty("end_key"))
                    if (!$util.isString(message.end_key))
                        return "end_key: string expected";
                if (message.itr_exhausted != null && message.hasOwnProperty("itr_exhausted"))
                    if (typeof message.itr_exhausted !== "boolean")
                        return "itr_exhausted: boolean expected";
                if (message.raw_reads != null && message.hasOwnProperty("raw_reads")) {
                    properties.reads_info = 1;
                    {
                        var error = $root.kvrwset.QueryReads.verify(message.raw_reads);
                        if (error)
                            return "raw_reads." + error;
                    }
                }
                if (message.reads_merkle_hashes != null && message.hasOwnProperty("reads_merkle_hashes")) {
                    if (properties.reads_info === 1)
                        return "reads_info: multiple values";
                    properties.reads_info = 1;
                    {
                        var error = $root.kvrwset.QueryReadsMerkleSummary.verify(message.reads_merkle_hashes);
                        if (error)
                            return "reads_merkle_hashes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a RangeQueryInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.RangeQueryInfo} RangeQueryInfo
             */
            RangeQueryInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.RangeQueryInfo)
                    return object;
                var message = new $root.kvrwset.RangeQueryInfo();
                if (object.start_key != null)
                    message.start_key = String(object.start_key);
                if (object.end_key != null)
                    message.end_key = String(object.end_key);
                if (object.itr_exhausted != null)
                    message.itr_exhausted = Boolean(object.itr_exhausted);
                if (object.raw_reads != null) {
                    if (typeof object.raw_reads !== "object")
                        throw TypeError(".kvrwset.RangeQueryInfo.raw_reads: object expected");
                    message.raw_reads = $root.kvrwset.QueryReads.fromObject(object.raw_reads);
                }
                if (object.reads_merkle_hashes != null) {
                    if (typeof object.reads_merkle_hashes !== "object")
                        throw TypeError(".kvrwset.RangeQueryInfo.reads_merkle_hashes: object expected");
                    message.reads_merkle_hashes = $root.kvrwset.QueryReadsMerkleSummary.fromObject(object.reads_merkle_hashes);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a RangeQueryInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {kvrwset.RangeQueryInfo} message RangeQueryInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RangeQueryInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.start_key = "";
                    object.end_key = "";
                    object.itr_exhausted = false;
                }
                if (message.start_key != null && message.hasOwnProperty("start_key"))
                    object.start_key = message.start_key;
                if (message.end_key != null && message.hasOwnProperty("end_key"))
                    object.end_key = message.end_key;
                if (message.itr_exhausted != null && message.hasOwnProperty("itr_exhausted"))
                    object.itr_exhausted = message.itr_exhausted;
                if (message.raw_reads != null && message.hasOwnProperty("raw_reads")) {
                    object.raw_reads = $root.kvrwset.QueryReads.toObject(message.raw_reads, options);
                    if (options.oneofs)
                        object.reads_info = "raw_reads";
                }
                if (message.reads_merkle_hashes != null && message.hasOwnProperty("reads_merkle_hashes")) {
                    object.reads_merkle_hashes = $root.kvrwset.QueryReadsMerkleSummary.toObject(message.reads_merkle_hashes, options);
                    if (options.oneofs)
                        object.reads_info = "reads_merkle_hashes";
                }
                return object;
            };
    
            /**
             * Converts this RangeQueryInfo to JSON.
             * @function toJSON
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RangeQueryInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RangeQueryInfo;
        })();
    
        kvrwset.QueryReads = (function() {
    
            /**
             * Properties of a QueryReads.
             * @memberof kvrwset
             * @interface IQueryReads
             * @property {Array.<kvrwset.IKVRead>|null} [kv_reads] QueryReads kv_reads
             */
    
            /**
             * Constructs a new QueryReads.
             * @memberof kvrwset
             * @classdesc Represents a QueryReads.
             * @implements IQueryReads
             * @constructor
             * @param {kvrwset.IQueryReads=} [properties] Properties to set
             */
            function QueryReads(properties) {
                this.kv_reads = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryReads kv_reads.
             * @member {Array.<kvrwset.IKVRead>} kv_reads
             * @memberof kvrwset.QueryReads
             * @instance
             */
            QueryReads.prototype.kv_reads = $util.emptyArray;
    
            /**
             * Creates a new QueryReads instance using the specified properties.
             * @function create
             * @memberof kvrwset.QueryReads
             * @static
             * @param {kvrwset.IQueryReads=} [properties] Properties to set
             * @returns {kvrwset.QueryReads} QueryReads instance
             */
            QueryReads.create = function create(properties) {
                return new QueryReads(properties);
            };
    
            /**
             * Encodes the specified QueryReads message. Does not implicitly {@link kvrwset.QueryReads.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.QueryReads
             * @static
             * @param {kvrwset.IQueryReads} message QueryReads message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryReads.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kv_reads != null && message.kv_reads.length)
                    for (var i = 0; i < message.kv_reads.length; ++i)
                        $root.kvrwset.KVRead.encode(message.kv_reads[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified QueryReads message, length delimited. Does not implicitly {@link kvrwset.QueryReads.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.QueryReads
             * @static
             * @param {kvrwset.IQueryReads} message QueryReads message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryReads.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryReads message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.QueryReads
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.QueryReads} QueryReads
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryReads.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.QueryReads();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.kv_reads && message.kv_reads.length))
                            message.kv_reads = [];
                        message.kv_reads.push($root.kvrwset.KVRead.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryReads message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.QueryReads
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.QueryReads} QueryReads
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryReads.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryReads message.
             * @function verify
             * @memberof kvrwset.QueryReads
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryReads.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kv_reads != null && message.hasOwnProperty("kv_reads")) {
                    if (!Array.isArray(message.kv_reads))
                        return "kv_reads: array expected";
                    for (var i = 0; i < message.kv_reads.length; ++i) {
                        var error = $root.kvrwset.KVRead.verify(message.kv_reads[i]);
                        if (error)
                            return "kv_reads." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a QueryReads message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.QueryReads
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.QueryReads} QueryReads
             */
            QueryReads.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.QueryReads)
                    return object;
                var message = new $root.kvrwset.QueryReads();
                if (object.kv_reads) {
                    if (!Array.isArray(object.kv_reads))
                        throw TypeError(".kvrwset.QueryReads.kv_reads: array expected");
                    message.kv_reads = [];
                    for (var i = 0; i < object.kv_reads.length; ++i) {
                        if (typeof object.kv_reads[i] !== "object")
                            throw TypeError(".kvrwset.QueryReads.kv_reads: object expected");
                        message.kv_reads[i] = $root.kvrwset.KVRead.fromObject(object.kv_reads[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryReads message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.QueryReads
             * @static
             * @param {kvrwset.QueryReads} message QueryReads
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryReads.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.kv_reads = [];
                if (message.kv_reads && message.kv_reads.length) {
                    object.kv_reads = [];
                    for (var j = 0; j < message.kv_reads.length; ++j)
                        object.kv_reads[j] = $root.kvrwset.KVRead.toObject(message.kv_reads[j], options);
                }
                return object;
            };
    
            /**
             * Converts this QueryReads to JSON.
             * @function toJSON
             * @memberof kvrwset.QueryReads
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryReads.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryReads;
        })();
    
        kvrwset.QueryReadsMerkleSummary = (function() {
    
            /**
             * Properties of a QueryReadsMerkleSummary.
             * @memberof kvrwset
             * @interface IQueryReadsMerkleSummary
             * @property {number|null} [max_degree] QueryReadsMerkleSummary max_degree
             * @property {number|null} [max_level] QueryReadsMerkleSummary max_level
             * @property {Array.<Uint8Array>|null} [max_level_hashes] QueryReadsMerkleSummary max_level_hashes
             */
    
            /**
             * Constructs a new QueryReadsMerkleSummary.
             * @memberof kvrwset
             * @classdesc Represents a QueryReadsMerkleSummary.
             * @implements IQueryReadsMerkleSummary
             * @constructor
             * @param {kvrwset.IQueryReadsMerkleSummary=} [properties] Properties to set
             */
            function QueryReadsMerkleSummary(properties) {
                this.max_level_hashes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryReadsMerkleSummary max_degree.
             * @member {number} max_degree
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @instance
             */
            QueryReadsMerkleSummary.prototype.max_degree = 0;
    
            /**
             * QueryReadsMerkleSummary max_level.
             * @member {number} max_level
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @instance
             */
            QueryReadsMerkleSummary.prototype.max_level = 0;
    
            /**
             * QueryReadsMerkleSummary max_level_hashes.
             * @member {Array.<Uint8Array>} max_level_hashes
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @instance
             */
            QueryReadsMerkleSummary.prototype.max_level_hashes = $util.emptyArray;
    
            /**
             * Creates a new QueryReadsMerkleSummary instance using the specified properties.
             * @function create
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {kvrwset.IQueryReadsMerkleSummary=} [properties] Properties to set
             * @returns {kvrwset.QueryReadsMerkleSummary} QueryReadsMerkleSummary instance
             */
            QueryReadsMerkleSummary.create = function create(properties) {
                return new QueryReadsMerkleSummary(properties);
            };
    
            /**
             * Encodes the specified QueryReadsMerkleSummary message. Does not implicitly {@link kvrwset.QueryReadsMerkleSummary.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {kvrwset.IQueryReadsMerkleSummary} message QueryReadsMerkleSummary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryReadsMerkleSummary.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.max_degree != null && Object.hasOwnProperty.call(message, "max_degree"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.max_degree);
                if (message.max_level != null && Object.hasOwnProperty.call(message, "max_level"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.max_level);
                if (message.max_level_hashes != null && message.max_level_hashes.length)
                    for (var i = 0; i < message.max_level_hashes.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.max_level_hashes[i]);
                return writer;
            };
    
            /**
             * Encodes the specified QueryReadsMerkleSummary message, length delimited. Does not implicitly {@link kvrwset.QueryReadsMerkleSummary.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {kvrwset.IQueryReadsMerkleSummary} message QueryReadsMerkleSummary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryReadsMerkleSummary.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryReadsMerkleSummary message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.QueryReadsMerkleSummary} QueryReadsMerkleSummary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryReadsMerkleSummary.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.QueryReadsMerkleSummary();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.max_degree = reader.uint32();
                        break;
                    case 2:
                        message.max_level = reader.uint32();
                        break;
                    case 3:
                        if (!(message.max_level_hashes && message.max_level_hashes.length))
                            message.max_level_hashes = [];
                        message.max_level_hashes.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryReadsMerkleSummary message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.QueryReadsMerkleSummary} QueryReadsMerkleSummary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryReadsMerkleSummary.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryReadsMerkleSummary message.
             * @function verify
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryReadsMerkleSummary.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.max_degree != null && message.hasOwnProperty("max_degree"))
                    if (!$util.isInteger(message.max_degree))
                        return "max_degree: integer expected";
                if (message.max_level != null && message.hasOwnProperty("max_level"))
                    if (!$util.isInteger(message.max_level))
                        return "max_level: integer expected";
                if (message.max_level_hashes != null && message.hasOwnProperty("max_level_hashes")) {
                    if (!Array.isArray(message.max_level_hashes))
                        return "max_level_hashes: array expected";
                    for (var i = 0; i < message.max_level_hashes.length; ++i)
                        if (!(message.max_level_hashes[i] && typeof message.max_level_hashes[i].length === "number" || $util.isString(message.max_level_hashes[i])))
                            return "max_level_hashes: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a QueryReadsMerkleSummary message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.QueryReadsMerkleSummary} QueryReadsMerkleSummary
             */
            QueryReadsMerkleSummary.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.QueryReadsMerkleSummary)
                    return object;
                var message = new $root.kvrwset.QueryReadsMerkleSummary();
                if (object.max_degree != null)
                    message.max_degree = object.max_degree >>> 0;
                if (object.max_level != null)
                    message.max_level = object.max_level >>> 0;
                if (object.max_level_hashes) {
                    if (!Array.isArray(object.max_level_hashes))
                        throw TypeError(".kvrwset.QueryReadsMerkleSummary.max_level_hashes: array expected");
                    message.max_level_hashes = [];
                    for (var i = 0; i < object.max_level_hashes.length; ++i)
                        if (typeof object.max_level_hashes[i] === "string")
                            $util.base64.decode(object.max_level_hashes[i], message.max_level_hashes[i] = $util.newBuffer($util.base64.length(object.max_level_hashes[i])), 0);
                        else if (object.max_level_hashes[i].length)
                            message.max_level_hashes[i] = object.max_level_hashes[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryReadsMerkleSummary message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {kvrwset.QueryReadsMerkleSummary} message QueryReadsMerkleSummary
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryReadsMerkleSummary.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.max_level_hashes = [];
                if (options.defaults) {
                    object.max_degree = 0;
                    object.max_level = 0;
                }
                if (message.max_degree != null && message.hasOwnProperty("max_degree"))
                    object.max_degree = message.max_degree;
                if (message.max_level != null && message.hasOwnProperty("max_level"))
                    object.max_level = message.max_level;
                if (message.max_level_hashes && message.max_level_hashes.length) {
                    object.max_level_hashes = [];
                    for (var j = 0; j < message.max_level_hashes.length; ++j)
                        object.max_level_hashes[j] = options.bytes === String ? $util.base64.encode(message.max_level_hashes[j], 0, message.max_level_hashes[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.max_level_hashes[j]) : message.max_level_hashes[j];
                }
                return object;
            };
    
            /**
             * Converts this QueryReadsMerkleSummary to JSON.
             * @function toJSON
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryReadsMerkleSummary.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryReadsMerkleSummary;
        })();
    
        return kvrwset;
    })();
    
    $root.rwset = (function() {
    
        /**
         * Namespace rwset.
         * @exports rwset
         * @namespace
         */
        var rwset = {};
    
        rwset.TxReadWriteSet = (function() {
    
            /**
             * Properties of a TxReadWriteSet.
             * @memberof rwset
             * @interface ITxReadWriteSet
             * @property {rwset.TxReadWriteSet.DataModel|null} [data_model] TxReadWriteSet data_model
             * @property {Array.<rwset.INsReadWriteSet>|null} [ns_rwset] TxReadWriteSet ns_rwset
             */
    
            /**
             * Constructs a new TxReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a TxReadWriteSet.
             * @implements ITxReadWriteSet
             * @constructor
             * @param {rwset.ITxReadWriteSet=} [properties] Properties to set
             */
            function TxReadWriteSet(properties) {
                this.ns_rwset = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TxReadWriteSet data_model.
             * @member {rwset.TxReadWriteSet.DataModel} data_model
             * @memberof rwset.TxReadWriteSet
             * @instance
             */
            TxReadWriteSet.prototype.data_model = 0;
    
            /**
             * TxReadWriteSet ns_rwset.
             * @member {Array.<rwset.INsReadWriteSet>} ns_rwset
             * @memberof rwset.TxReadWriteSet
             * @instance
             */
            TxReadWriteSet.prototype.ns_rwset = $util.emptyArray;
    
            /**
             * Creates a new TxReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {rwset.ITxReadWriteSet=} [properties] Properties to set
             * @returns {rwset.TxReadWriteSet} TxReadWriteSet instance
             */
            TxReadWriteSet.create = function create(properties) {
                return new TxReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified TxReadWriteSet message. Does not implicitly {@link rwset.TxReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {rwset.ITxReadWriteSet} message TxReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data_model != null && Object.hasOwnProperty.call(message, "data_model"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.data_model);
                if (message.ns_rwset != null && message.ns_rwset.length)
                    for (var i = 0; i < message.ns_rwset.length; ++i)
                        $root.rwset.NsReadWriteSet.encode(message.ns_rwset[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified TxReadWriteSet message, length delimited. Does not implicitly {@link rwset.TxReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {rwset.ITxReadWriteSet} message TxReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TxReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.TxReadWriteSet} TxReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.TxReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data_model = reader.int32();
                        break;
                    case 2:
                        if (!(message.ns_rwset && message.ns_rwset.length))
                            message.ns_rwset = [];
                        message.ns_rwset.push($root.rwset.NsReadWriteSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TxReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.TxReadWriteSet} TxReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TxReadWriteSet message.
             * @function verify
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data_model != null && message.hasOwnProperty("data_model"))
                    switch (message.data_model) {
                    default:
                        return "data_model: enum value expected";
                    case 0:
                        break;
                    }
                if (message.ns_rwset != null && message.hasOwnProperty("ns_rwset")) {
                    if (!Array.isArray(message.ns_rwset))
                        return "ns_rwset: array expected";
                    for (var i = 0; i < message.ns_rwset.length; ++i) {
                        var error = $root.rwset.NsReadWriteSet.verify(message.ns_rwset[i]);
                        if (error)
                            return "ns_rwset." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a TxReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.TxReadWriteSet} TxReadWriteSet
             */
            TxReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.TxReadWriteSet)
                    return object;
                var message = new $root.rwset.TxReadWriteSet();
                switch (object.data_model) {
                case "KV":
                case 0:
                    message.data_model = 0;
                    break;
                }
                if (object.ns_rwset) {
                    if (!Array.isArray(object.ns_rwset))
                        throw TypeError(".rwset.TxReadWriteSet.ns_rwset: array expected");
                    message.ns_rwset = [];
                    for (var i = 0; i < object.ns_rwset.length; ++i) {
                        if (typeof object.ns_rwset[i] !== "object")
                            throw TypeError(".rwset.TxReadWriteSet.ns_rwset: object expected");
                        message.ns_rwset[i] = $root.rwset.NsReadWriteSet.fromObject(object.ns_rwset[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a TxReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {rwset.TxReadWriteSet} message TxReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ns_rwset = [];
                if (options.defaults)
                    object.data_model = options.enums === String ? "KV" : 0;
                if (message.data_model != null && message.hasOwnProperty("data_model"))
                    object.data_model = options.enums === String ? $root.rwset.TxReadWriteSet.DataModel[message.data_model] : message.data_model;
                if (message.ns_rwset && message.ns_rwset.length) {
                    object.ns_rwset = [];
                    for (var j = 0; j < message.ns_rwset.length; ++j)
                        object.ns_rwset[j] = $root.rwset.NsReadWriteSet.toObject(message.ns_rwset[j], options);
                }
                return object;
            };
    
            /**
             * Converts this TxReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.TxReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * DataModel enum.
             * @name rwset.TxReadWriteSet.DataModel
             * @enum {number}
             * @property {number} KV=0 KV value
             */
            TxReadWriteSet.DataModel = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "KV"] = 0;
                return values;
            })();
    
            return TxReadWriteSet;
        })();
    
        rwset.NsReadWriteSet = (function() {
    
            /**
             * Properties of a NsReadWriteSet.
             * @memberof rwset
             * @interface INsReadWriteSet
             * @property {string|null} [namespace] NsReadWriteSet namespace
             * @property {Uint8Array|null} [rwset] NsReadWriteSet rwset
             * @property {Array.<rwset.ICollectionHashedReadWriteSet>|null} [collection_hashed_rwset] NsReadWriteSet collection_hashed_rwset
             */
    
            /**
             * Constructs a new NsReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a NsReadWriteSet.
             * @implements INsReadWriteSet
             * @constructor
             * @param {rwset.INsReadWriteSet=} [properties] Properties to set
             */
            function NsReadWriteSet(properties) {
                this.collection_hashed_rwset = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NsReadWriteSet namespace.
             * @member {string} namespace
             * @memberof rwset.NsReadWriteSet
             * @instance
             */
            NsReadWriteSet.prototype.namespace = "";
    
            /**
             * NsReadWriteSet rwset.
             * @member {Uint8Array} rwset
             * @memberof rwset.NsReadWriteSet
             * @instance
             */
            NsReadWriteSet.prototype.rwset = $util.newBuffer([]);
    
            /**
             * NsReadWriteSet collection_hashed_rwset.
             * @member {Array.<rwset.ICollectionHashedReadWriteSet>} collection_hashed_rwset
             * @memberof rwset.NsReadWriteSet
             * @instance
             */
            NsReadWriteSet.prototype.collection_hashed_rwset = $util.emptyArray;
    
            /**
             * Creates a new NsReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {rwset.INsReadWriteSet=} [properties] Properties to set
             * @returns {rwset.NsReadWriteSet} NsReadWriteSet instance
             */
            NsReadWriteSet.create = function create(properties) {
                return new NsReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified NsReadWriteSet message. Does not implicitly {@link rwset.NsReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {rwset.INsReadWriteSet} message NsReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NsReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.namespace != null && Object.hasOwnProperty.call(message, "namespace"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
                if (message.rwset != null && Object.hasOwnProperty.call(message, "rwset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rwset);
                if (message.collection_hashed_rwset != null && message.collection_hashed_rwset.length)
                    for (var i = 0; i < message.collection_hashed_rwset.length; ++i)
                        $root.rwset.CollectionHashedReadWriteSet.encode(message.collection_hashed_rwset[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified NsReadWriteSet message, length delimited. Does not implicitly {@link rwset.NsReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {rwset.INsReadWriteSet} message NsReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NsReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NsReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.NsReadWriteSet} NsReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NsReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.NsReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.namespace = reader.string();
                        break;
                    case 2:
                        message.rwset = reader.bytes();
                        break;
                    case 3:
                        if (!(message.collection_hashed_rwset && message.collection_hashed_rwset.length))
                            message.collection_hashed_rwset = [];
                        message.collection_hashed_rwset.push($root.rwset.CollectionHashedReadWriteSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NsReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.NsReadWriteSet} NsReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NsReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NsReadWriteSet message.
             * @function verify
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NsReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    if (!(message.rwset && typeof message.rwset.length === "number" || $util.isString(message.rwset)))
                        return "rwset: buffer expected";
                if (message.collection_hashed_rwset != null && message.hasOwnProperty("collection_hashed_rwset")) {
                    if (!Array.isArray(message.collection_hashed_rwset))
                        return "collection_hashed_rwset: array expected";
                    for (var i = 0; i < message.collection_hashed_rwset.length; ++i) {
                        var error = $root.rwset.CollectionHashedReadWriteSet.verify(message.collection_hashed_rwset[i]);
                        if (error)
                            return "collection_hashed_rwset." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a NsReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.NsReadWriteSet} NsReadWriteSet
             */
            NsReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.NsReadWriteSet)
                    return object;
                var message = new $root.rwset.NsReadWriteSet();
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.rwset != null)
                    if (typeof object.rwset === "string")
                        $util.base64.decode(object.rwset, message.rwset = $util.newBuffer($util.base64.length(object.rwset)), 0);
                    else if (object.rwset.length)
                        message.rwset = object.rwset;
                if (object.collection_hashed_rwset) {
                    if (!Array.isArray(object.collection_hashed_rwset))
                        throw TypeError(".rwset.NsReadWriteSet.collection_hashed_rwset: array expected");
                    message.collection_hashed_rwset = [];
                    for (var i = 0; i < object.collection_hashed_rwset.length; ++i) {
                        if (typeof object.collection_hashed_rwset[i] !== "object")
                            throw TypeError(".rwset.NsReadWriteSet.collection_hashed_rwset: object expected");
                        message.collection_hashed_rwset[i] = $root.rwset.CollectionHashedReadWriteSet.fromObject(object.collection_hashed_rwset[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a NsReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {rwset.NsReadWriteSet} message NsReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NsReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.collection_hashed_rwset = [];
                if (options.defaults) {
                    object.namespace = "";
                    if (options.bytes === String)
                        object.rwset = "";
                    else {
                        object.rwset = [];
                        if (options.bytes !== Array)
                            object.rwset = $util.newBuffer(object.rwset);
                    }
                }
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    object.rwset = options.bytes === String ? $util.base64.encode(message.rwset, 0, message.rwset.length) : options.bytes === Array ? Array.prototype.slice.call(message.rwset) : message.rwset;
                if (message.collection_hashed_rwset && message.collection_hashed_rwset.length) {
                    object.collection_hashed_rwset = [];
                    for (var j = 0; j < message.collection_hashed_rwset.length; ++j)
                        object.collection_hashed_rwset[j] = $root.rwset.CollectionHashedReadWriteSet.toObject(message.collection_hashed_rwset[j], options);
                }
                return object;
            };
    
            /**
             * Converts this NsReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.NsReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NsReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return NsReadWriteSet;
        })();
    
        rwset.CollectionHashedReadWriteSet = (function() {
    
            /**
             * Properties of a CollectionHashedReadWriteSet.
             * @memberof rwset
             * @interface ICollectionHashedReadWriteSet
             * @property {string|null} [collection_name] CollectionHashedReadWriteSet collection_name
             * @property {Uint8Array|null} [hashed_rwset] CollectionHashedReadWriteSet hashed_rwset
             * @property {Uint8Array|null} [pvt_rwset_hash] CollectionHashedReadWriteSet pvt_rwset_hash
             */
    
            /**
             * Constructs a new CollectionHashedReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a CollectionHashedReadWriteSet.
             * @implements ICollectionHashedReadWriteSet
             * @constructor
             * @param {rwset.ICollectionHashedReadWriteSet=} [properties] Properties to set
             */
            function CollectionHashedReadWriteSet(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionHashedReadWriteSet collection_name.
             * @member {string} collection_name
             * @memberof rwset.CollectionHashedReadWriteSet
             * @instance
             */
            CollectionHashedReadWriteSet.prototype.collection_name = "";
    
            /**
             * CollectionHashedReadWriteSet hashed_rwset.
             * @member {Uint8Array} hashed_rwset
             * @memberof rwset.CollectionHashedReadWriteSet
             * @instance
             */
            CollectionHashedReadWriteSet.prototype.hashed_rwset = $util.newBuffer([]);
    
            /**
             * CollectionHashedReadWriteSet pvt_rwset_hash.
             * @member {Uint8Array} pvt_rwset_hash
             * @memberof rwset.CollectionHashedReadWriteSet
             * @instance
             */
            CollectionHashedReadWriteSet.prototype.pvt_rwset_hash = $util.newBuffer([]);
    
            /**
             * Creates a new CollectionHashedReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {rwset.ICollectionHashedReadWriteSet=} [properties] Properties to set
             * @returns {rwset.CollectionHashedReadWriteSet} CollectionHashedReadWriteSet instance
             */
            CollectionHashedReadWriteSet.create = function create(properties) {
                return new CollectionHashedReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified CollectionHashedReadWriteSet message. Does not implicitly {@link rwset.CollectionHashedReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {rwset.ICollectionHashedReadWriteSet} message CollectionHashedReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionHashedReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection_name != null && Object.hasOwnProperty.call(message, "collection_name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collection_name);
                if (message.hashed_rwset != null && Object.hasOwnProperty.call(message, "hashed_rwset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hashed_rwset);
                if (message.pvt_rwset_hash != null && Object.hasOwnProperty.call(message, "pvt_rwset_hash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pvt_rwset_hash);
                return writer;
            };
    
            /**
             * Encodes the specified CollectionHashedReadWriteSet message, length delimited. Does not implicitly {@link rwset.CollectionHashedReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {rwset.ICollectionHashedReadWriteSet} message CollectionHashedReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionHashedReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionHashedReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.CollectionHashedReadWriteSet} CollectionHashedReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionHashedReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.CollectionHashedReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection_name = reader.string();
                        break;
                    case 2:
                        message.hashed_rwset = reader.bytes();
                        break;
                    case 3:
                        message.pvt_rwset_hash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionHashedReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.CollectionHashedReadWriteSet} CollectionHashedReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionHashedReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionHashedReadWriteSet message.
             * @function verify
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionHashedReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection_name != null && message.hasOwnProperty("collection_name"))
                    if (!$util.isString(message.collection_name))
                        return "collection_name: string expected";
                if (message.hashed_rwset != null && message.hasOwnProperty("hashed_rwset"))
                    if (!(message.hashed_rwset && typeof message.hashed_rwset.length === "number" || $util.isString(message.hashed_rwset)))
                        return "hashed_rwset: buffer expected";
                if (message.pvt_rwset_hash != null && message.hasOwnProperty("pvt_rwset_hash"))
                    if (!(message.pvt_rwset_hash && typeof message.pvt_rwset_hash.length === "number" || $util.isString(message.pvt_rwset_hash)))
                        return "pvt_rwset_hash: buffer expected";
                return null;
            };
    
            /**
             * Creates a CollectionHashedReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.CollectionHashedReadWriteSet} CollectionHashedReadWriteSet
             */
            CollectionHashedReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.CollectionHashedReadWriteSet)
                    return object;
                var message = new $root.rwset.CollectionHashedReadWriteSet();
                if (object.collection_name != null)
                    message.collection_name = String(object.collection_name);
                if (object.hashed_rwset != null)
                    if (typeof object.hashed_rwset === "string")
                        $util.base64.decode(object.hashed_rwset, message.hashed_rwset = $util.newBuffer($util.base64.length(object.hashed_rwset)), 0);
                    else if (object.hashed_rwset.length)
                        message.hashed_rwset = object.hashed_rwset;
                if (object.pvt_rwset_hash != null)
                    if (typeof object.pvt_rwset_hash === "string")
                        $util.base64.decode(object.pvt_rwset_hash, message.pvt_rwset_hash = $util.newBuffer($util.base64.length(object.pvt_rwset_hash)), 0);
                    else if (object.pvt_rwset_hash.length)
                        message.pvt_rwset_hash = object.pvt_rwset_hash;
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionHashedReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {rwset.CollectionHashedReadWriteSet} message CollectionHashedReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionHashedReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection_name = "";
                    if (options.bytes === String)
                        object.hashed_rwset = "";
                    else {
                        object.hashed_rwset = [];
                        if (options.bytes !== Array)
                            object.hashed_rwset = $util.newBuffer(object.hashed_rwset);
                    }
                    if (options.bytes === String)
                        object.pvt_rwset_hash = "";
                    else {
                        object.pvt_rwset_hash = [];
                        if (options.bytes !== Array)
                            object.pvt_rwset_hash = $util.newBuffer(object.pvt_rwset_hash);
                    }
                }
                if (message.collection_name != null && message.hasOwnProperty("collection_name"))
                    object.collection_name = message.collection_name;
                if (message.hashed_rwset != null && message.hasOwnProperty("hashed_rwset"))
                    object.hashed_rwset = options.bytes === String ? $util.base64.encode(message.hashed_rwset, 0, message.hashed_rwset.length) : options.bytes === Array ? Array.prototype.slice.call(message.hashed_rwset) : message.hashed_rwset;
                if (message.pvt_rwset_hash != null && message.hasOwnProperty("pvt_rwset_hash"))
                    object.pvt_rwset_hash = options.bytes === String ? $util.base64.encode(message.pvt_rwset_hash, 0, message.pvt_rwset_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.pvt_rwset_hash) : message.pvt_rwset_hash;
                return object;
            };
    
            /**
             * Converts this CollectionHashedReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.CollectionHashedReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionHashedReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionHashedReadWriteSet;
        })();
    
        rwset.TxPvtReadWriteSet = (function() {
    
            /**
             * Properties of a TxPvtReadWriteSet.
             * @memberof rwset
             * @interface ITxPvtReadWriteSet
             * @property {rwset.TxReadWriteSet.DataModel|null} [data_model] TxPvtReadWriteSet data_model
             * @property {Array.<rwset.INsPvtReadWriteSet>|null} [ns_pvt_rwset] TxPvtReadWriteSet ns_pvt_rwset
             */
    
            /**
             * Constructs a new TxPvtReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a TxPvtReadWriteSet.
             * @implements ITxPvtReadWriteSet
             * @constructor
             * @param {rwset.ITxPvtReadWriteSet=} [properties] Properties to set
             */
            function TxPvtReadWriteSet(properties) {
                this.ns_pvt_rwset = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TxPvtReadWriteSet data_model.
             * @member {rwset.TxReadWriteSet.DataModel} data_model
             * @memberof rwset.TxPvtReadWriteSet
             * @instance
             */
            TxPvtReadWriteSet.prototype.data_model = 0;
    
            /**
             * TxPvtReadWriteSet ns_pvt_rwset.
             * @member {Array.<rwset.INsPvtReadWriteSet>} ns_pvt_rwset
             * @memberof rwset.TxPvtReadWriteSet
             * @instance
             */
            TxPvtReadWriteSet.prototype.ns_pvt_rwset = $util.emptyArray;
    
            /**
             * Creates a new TxPvtReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {rwset.ITxPvtReadWriteSet=} [properties] Properties to set
             * @returns {rwset.TxPvtReadWriteSet} TxPvtReadWriteSet instance
             */
            TxPvtReadWriteSet.create = function create(properties) {
                return new TxPvtReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified TxPvtReadWriteSet message. Does not implicitly {@link rwset.TxPvtReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {rwset.ITxPvtReadWriteSet} message TxPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxPvtReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data_model != null && Object.hasOwnProperty.call(message, "data_model"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.data_model);
                if (message.ns_pvt_rwset != null && message.ns_pvt_rwset.length)
                    for (var i = 0; i < message.ns_pvt_rwset.length; ++i)
                        $root.rwset.NsPvtReadWriteSet.encode(message.ns_pvt_rwset[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified TxPvtReadWriteSet message, length delimited. Does not implicitly {@link rwset.TxPvtReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {rwset.ITxPvtReadWriteSet} message TxPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxPvtReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TxPvtReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.TxPvtReadWriteSet} TxPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxPvtReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.TxPvtReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data_model = reader.int32();
                        break;
                    case 2:
                        if (!(message.ns_pvt_rwset && message.ns_pvt_rwset.length))
                            message.ns_pvt_rwset = [];
                        message.ns_pvt_rwset.push($root.rwset.NsPvtReadWriteSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TxPvtReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.TxPvtReadWriteSet} TxPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxPvtReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TxPvtReadWriteSet message.
             * @function verify
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxPvtReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data_model != null && message.hasOwnProperty("data_model"))
                    switch (message.data_model) {
                    default:
                        return "data_model: enum value expected";
                    case 0:
                        break;
                    }
                if (message.ns_pvt_rwset != null && message.hasOwnProperty("ns_pvt_rwset")) {
                    if (!Array.isArray(message.ns_pvt_rwset))
                        return "ns_pvt_rwset: array expected";
                    for (var i = 0; i < message.ns_pvt_rwset.length; ++i) {
                        var error = $root.rwset.NsPvtReadWriteSet.verify(message.ns_pvt_rwset[i]);
                        if (error)
                            return "ns_pvt_rwset." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a TxPvtReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.TxPvtReadWriteSet} TxPvtReadWriteSet
             */
            TxPvtReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.TxPvtReadWriteSet)
                    return object;
                var message = new $root.rwset.TxPvtReadWriteSet();
                switch (object.data_model) {
                case "KV":
                case 0:
                    message.data_model = 0;
                    break;
                }
                if (object.ns_pvt_rwset) {
                    if (!Array.isArray(object.ns_pvt_rwset))
                        throw TypeError(".rwset.TxPvtReadWriteSet.ns_pvt_rwset: array expected");
                    message.ns_pvt_rwset = [];
                    for (var i = 0; i < object.ns_pvt_rwset.length; ++i) {
                        if (typeof object.ns_pvt_rwset[i] !== "object")
                            throw TypeError(".rwset.TxPvtReadWriteSet.ns_pvt_rwset: object expected");
                        message.ns_pvt_rwset[i] = $root.rwset.NsPvtReadWriteSet.fromObject(object.ns_pvt_rwset[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a TxPvtReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {rwset.TxPvtReadWriteSet} message TxPvtReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxPvtReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ns_pvt_rwset = [];
                if (options.defaults)
                    object.data_model = options.enums === String ? "KV" : 0;
                if (message.data_model != null && message.hasOwnProperty("data_model"))
                    object.data_model = options.enums === String ? $root.rwset.TxReadWriteSet.DataModel[message.data_model] : message.data_model;
                if (message.ns_pvt_rwset && message.ns_pvt_rwset.length) {
                    object.ns_pvt_rwset = [];
                    for (var j = 0; j < message.ns_pvt_rwset.length; ++j)
                        object.ns_pvt_rwset[j] = $root.rwset.NsPvtReadWriteSet.toObject(message.ns_pvt_rwset[j], options);
                }
                return object;
            };
    
            /**
             * Converts this TxPvtReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.TxPvtReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxPvtReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TxPvtReadWriteSet;
        })();
    
        rwset.NsPvtReadWriteSet = (function() {
    
            /**
             * Properties of a NsPvtReadWriteSet.
             * @memberof rwset
             * @interface INsPvtReadWriteSet
             * @property {string|null} [namespace] NsPvtReadWriteSet namespace
             * @property {Array.<rwset.ICollectionPvtReadWriteSet>|null} [collection_pvt_rwset] NsPvtReadWriteSet collection_pvt_rwset
             */
    
            /**
             * Constructs a new NsPvtReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a NsPvtReadWriteSet.
             * @implements INsPvtReadWriteSet
             * @constructor
             * @param {rwset.INsPvtReadWriteSet=} [properties] Properties to set
             */
            function NsPvtReadWriteSet(properties) {
                this.collection_pvt_rwset = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NsPvtReadWriteSet namespace.
             * @member {string} namespace
             * @memberof rwset.NsPvtReadWriteSet
             * @instance
             */
            NsPvtReadWriteSet.prototype.namespace = "";
    
            /**
             * NsPvtReadWriteSet collection_pvt_rwset.
             * @member {Array.<rwset.ICollectionPvtReadWriteSet>} collection_pvt_rwset
             * @memberof rwset.NsPvtReadWriteSet
             * @instance
             */
            NsPvtReadWriteSet.prototype.collection_pvt_rwset = $util.emptyArray;
    
            /**
             * Creates a new NsPvtReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {rwset.INsPvtReadWriteSet=} [properties] Properties to set
             * @returns {rwset.NsPvtReadWriteSet} NsPvtReadWriteSet instance
             */
            NsPvtReadWriteSet.create = function create(properties) {
                return new NsPvtReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified NsPvtReadWriteSet message. Does not implicitly {@link rwset.NsPvtReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {rwset.INsPvtReadWriteSet} message NsPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NsPvtReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.namespace != null && Object.hasOwnProperty.call(message, "namespace"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
                if (message.collection_pvt_rwset != null && message.collection_pvt_rwset.length)
                    for (var i = 0; i < message.collection_pvt_rwset.length; ++i)
                        $root.rwset.CollectionPvtReadWriteSet.encode(message.collection_pvt_rwset[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified NsPvtReadWriteSet message, length delimited. Does not implicitly {@link rwset.NsPvtReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {rwset.INsPvtReadWriteSet} message NsPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NsPvtReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NsPvtReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.NsPvtReadWriteSet} NsPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NsPvtReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.NsPvtReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.namespace = reader.string();
                        break;
                    case 2:
                        if (!(message.collection_pvt_rwset && message.collection_pvt_rwset.length))
                            message.collection_pvt_rwset = [];
                        message.collection_pvt_rwset.push($root.rwset.CollectionPvtReadWriteSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NsPvtReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.NsPvtReadWriteSet} NsPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NsPvtReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NsPvtReadWriteSet message.
             * @function verify
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NsPvtReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.collection_pvt_rwset != null && message.hasOwnProperty("collection_pvt_rwset")) {
                    if (!Array.isArray(message.collection_pvt_rwset))
                        return "collection_pvt_rwset: array expected";
                    for (var i = 0; i < message.collection_pvt_rwset.length; ++i) {
                        var error = $root.rwset.CollectionPvtReadWriteSet.verify(message.collection_pvt_rwset[i]);
                        if (error)
                            return "collection_pvt_rwset." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a NsPvtReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.NsPvtReadWriteSet} NsPvtReadWriteSet
             */
            NsPvtReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.NsPvtReadWriteSet)
                    return object;
                var message = new $root.rwset.NsPvtReadWriteSet();
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.collection_pvt_rwset) {
                    if (!Array.isArray(object.collection_pvt_rwset))
                        throw TypeError(".rwset.NsPvtReadWriteSet.collection_pvt_rwset: array expected");
                    message.collection_pvt_rwset = [];
                    for (var i = 0; i < object.collection_pvt_rwset.length; ++i) {
                        if (typeof object.collection_pvt_rwset[i] !== "object")
                            throw TypeError(".rwset.NsPvtReadWriteSet.collection_pvt_rwset: object expected");
                        message.collection_pvt_rwset[i] = $root.rwset.CollectionPvtReadWriteSet.fromObject(object.collection_pvt_rwset[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a NsPvtReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {rwset.NsPvtReadWriteSet} message NsPvtReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NsPvtReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.collection_pvt_rwset = [];
                if (options.defaults)
                    object.namespace = "";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.collection_pvt_rwset && message.collection_pvt_rwset.length) {
                    object.collection_pvt_rwset = [];
                    for (var j = 0; j < message.collection_pvt_rwset.length; ++j)
                        object.collection_pvt_rwset[j] = $root.rwset.CollectionPvtReadWriteSet.toObject(message.collection_pvt_rwset[j], options);
                }
                return object;
            };
    
            /**
             * Converts this NsPvtReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.NsPvtReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NsPvtReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return NsPvtReadWriteSet;
        })();
    
        rwset.CollectionPvtReadWriteSet = (function() {
    
            /**
             * Properties of a CollectionPvtReadWriteSet.
             * @memberof rwset
             * @interface ICollectionPvtReadWriteSet
             * @property {string|null} [collection_name] CollectionPvtReadWriteSet collection_name
             * @property {Uint8Array|null} [rwset] CollectionPvtReadWriteSet rwset
             */
    
            /**
             * Constructs a new CollectionPvtReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a CollectionPvtReadWriteSet.
             * @implements ICollectionPvtReadWriteSet
             * @constructor
             * @param {rwset.ICollectionPvtReadWriteSet=} [properties] Properties to set
             */
            function CollectionPvtReadWriteSet(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionPvtReadWriteSet collection_name.
             * @member {string} collection_name
             * @memberof rwset.CollectionPvtReadWriteSet
             * @instance
             */
            CollectionPvtReadWriteSet.prototype.collection_name = "";
    
            /**
             * CollectionPvtReadWriteSet rwset.
             * @member {Uint8Array} rwset
             * @memberof rwset.CollectionPvtReadWriteSet
             * @instance
             */
            CollectionPvtReadWriteSet.prototype.rwset = $util.newBuffer([]);
    
            /**
             * Creates a new CollectionPvtReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {rwset.ICollectionPvtReadWriteSet=} [properties] Properties to set
             * @returns {rwset.CollectionPvtReadWriteSet} CollectionPvtReadWriteSet instance
             */
            CollectionPvtReadWriteSet.create = function create(properties) {
                return new CollectionPvtReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified CollectionPvtReadWriteSet message. Does not implicitly {@link rwset.CollectionPvtReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {rwset.ICollectionPvtReadWriteSet} message CollectionPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionPvtReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection_name != null && Object.hasOwnProperty.call(message, "collection_name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collection_name);
                if (message.rwset != null && Object.hasOwnProperty.call(message, "rwset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rwset);
                return writer;
            };
    
            /**
             * Encodes the specified CollectionPvtReadWriteSet message, length delimited. Does not implicitly {@link rwset.CollectionPvtReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {rwset.ICollectionPvtReadWriteSet} message CollectionPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionPvtReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionPvtReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.CollectionPvtReadWriteSet} CollectionPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionPvtReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.CollectionPvtReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection_name = reader.string();
                        break;
                    case 2:
                        message.rwset = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionPvtReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.CollectionPvtReadWriteSet} CollectionPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionPvtReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionPvtReadWriteSet message.
             * @function verify
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionPvtReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection_name != null && message.hasOwnProperty("collection_name"))
                    if (!$util.isString(message.collection_name))
                        return "collection_name: string expected";
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    if (!(message.rwset && typeof message.rwset.length === "number" || $util.isString(message.rwset)))
                        return "rwset: buffer expected";
                return null;
            };
    
            /**
             * Creates a CollectionPvtReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.CollectionPvtReadWriteSet} CollectionPvtReadWriteSet
             */
            CollectionPvtReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.CollectionPvtReadWriteSet)
                    return object;
                var message = new $root.rwset.CollectionPvtReadWriteSet();
                if (object.collection_name != null)
                    message.collection_name = String(object.collection_name);
                if (object.rwset != null)
                    if (typeof object.rwset === "string")
                        $util.base64.decode(object.rwset, message.rwset = $util.newBuffer($util.base64.length(object.rwset)), 0);
                    else if (object.rwset.length)
                        message.rwset = object.rwset;
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionPvtReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {rwset.CollectionPvtReadWriteSet} message CollectionPvtReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionPvtReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection_name = "";
                    if (options.bytes === String)
                        object.rwset = "";
                    else {
                        object.rwset = [];
                        if (options.bytes !== Array)
                            object.rwset = $util.newBuffer(object.rwset);
                    }
                }
                if (message.collection_name != null && message.hasOwnProperty("collection_name"))
                    object.collection_name = message.collection_name;
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    object.rwset = options.bytes === String ? $util.base64.encode(message.rwset, 0, message.rwset.length) : options.bytes === Array ? Array.prototype.slice.call(message.rwset) : message.rwset;
                return object;
            };
    
            /**
             * Converts this CollectionPvtReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.CollectionPvtReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionPvtReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionPvtReadWriteSet;
        })();
    
        return rwset;
    })();
    
    $root.queryresult = (function() {
    
        /**
         * Namespace queryresult.
         * @exports queryresult
         * @namespace
         */
        var queryresult = {};
    
        queryresult.KV = (function() {
    
            /**
             * Properties of a KV.
             * @memberof queryresult
             * @interface IKV
             * @property {string|null} [namespace] KV namespace
             * @property {string|null} [key] KV key
             * @property {Uint8Array|null} [value] KV value
             */
    
            /**
             * Constructs a new KV.
             * @memberof queryresult
             * @classdesc Represents a KV.
             * @implements IKV
             * @constructor
             * @param {queryresult.IKV=} [properties] Properties to set
             */
            function KV(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KV namespace.
             * @member {string} namespace
             * @memberof queryresult.KV
             * @instance
             */
            KV.prototype.namespace = "";
    
            /**
             * KV key.
             * @member {string} key
             * @memberof queryresult.KV
             * @instance
             */
            KV.prototype.key = "";
    
            /**
             * KV value.
             * @member {Uint8Array} value
             * @memberof queryresult.KV
             * @instance
             */
            KV.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new KV instance using the specified properties.
             * @function create
             * @memberof queryresult.KV
             * @static
             * @param {queryresult.IKV=} [properties] Properties to set
             * @returns {queryresult.KV} KV instance
             */
            KV.create = function create(properties) {
                return new KV(properties);
            };
    
            /**
             * Encodes the specified KV message. Does not implicitly {@link queryresult.KV.verify|verify} messages.
             * @function encode
             * @memberof queryresult.KV
             * @static
             * @param {queryresult.IKV} message KV message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KV.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.namespace != null && Object.hasOwnProperty.call(message, "namespace"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified KV message, length delimited. Does not implicitly {@link queryresult.KV.verify|verify} messages.
             * @function encodeDelimited
             * @memberof queryresult.KV
             * @static
             * @param {queryresult.IKV} message KV message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KV.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KV message from the specified reader or buffer.
             * @function decode
             * @memberof queryresult.KV
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {queryresult.KV} KV
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KV.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.queryresult.KV();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.namespace = reader.string();
                        break;
                    case 2:
                        message.key = reader.string();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KV message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof queryresult.KV
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {queryresult.KV} KV
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KV.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KV message.
             * @function verify
             * @memberof queryresult.KV
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KV.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a KV message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof queryresult.KV
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {queryresult.KV} KV
             */
            KV.fromObject = function fromObject(object) {
                if (object instanceof $root.queryresult.KV)
                    return object;
                var message = new $root.queryresult.KV();
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a KV message. Also converts values to other types if specified.
             * @function toObject
             * @memberof queryresult.KV
             * @static
             * @param {queryresult.KV} message KV
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KV.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.namespace = "";
                    object.key = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this KV to JSON.
             * @function toJSON
             * @memberof queryresult.KV
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KV.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KV;
        })();
    
        queryresult.KeyModification = (function() {
    
            /**
             * Properties of a KeyModification.
             * @memberof queryresult
             * @interface IKeyModification
             * @property {string|null} [tx_id] KeyModification tx_id
             * @property {Uint8Array|null} [value] KeyModification value
             * @property {google.protobuf.ITimestamp|null} [timestamp] KeyModification timestamp
             * @property {boolean|null} [is_delete] KeyModification is_delete
             */
    
            /**
             * Constructs a new KeyModification.
             * @memberof queryresult
             * @cl